<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>面向C++语言的外部模块系统--Sin of Sloth</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">面向C++语言的外部模块系统--Sin of Sloth</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-24 09:24:55</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>不久前，约翰·普莱斯和我为C语言发明了一个外部模块系统。它对我们很有效，但从未流行起来。也许这会对你们中的一些人有用。</p><p>Sloth是一个雄心勃勃的项目(可供2到3个人使用)的一部分，该项目名为Popshop(我在我的软件成功帖子中提到了这一点)。</p><p>这一切开始时都是无害的-为什么我不编写一个Lucid解释器呢？</p><p>一个相反的论点是：我已经有了一个，正如我在之前的帖子中已经提到的那样。这主要是A·福斯蒂尼的作品，他是我的第一个学生，也是博士后。它运行得很好，拥有1985年的Lucid书中使用的所有功能，以及出色的错误处理和UNIX逃逸功能，您还想要什么呢？</p><p>但我有更大的抱负。在Lucid这本书出版后，我突然意识到，同样的原则也可以应用于类似的项目，例如，三维电子表格。</p><p>福斯蒂尼的翻译帮不上忙。它(事实证明是明智的)是一个单一目的的程序，而且引导起来很笨拙。Faustini已经练习了我所说的今天的编程-产生了一些立即有用的东西，如果与明天的项目无关的话。</p><p>我发誓我不会再犯同样的--在我看来--错误。我将为未来编程，并产生通用的可重用代码，这些代码可以用于未来的内涵编程项目；包括一些我甚至还没有想过的代码。</p><p>我不知道那会有多难。我最终不得不实现像Sloth这样的整套工具，这些工具需要的工作量和独创性与我脑海中的任何未来项目一样多。我滑下了过度设计的滑坡路。</p><p>但我就是不能让自己暂时写作，也不能为浮斯蒂尼翻译机写出一个单一目的的继任者。事实证明，这并不是一个好的职业选择。</p><p>我开始计划所有项目之母，很快就明白了软件可以分成许多独立的组件。</p><p>一个统一的主题是，所有未来的“可交付成果”(如电子表格)都将基于POP-2的数据类型和语法，就像plucid(Faustini实现的语言)一样。(这就是“Popshop”这个名字的由来。)。</p><p>POP-2已经消亡很久了，但加入了一些聪明的想法。它有数字、字符串、单词(原子)和嵌套列表，基本上与LISP相同。但是它使用了用户友好的中缀语法，就像pLucid和(我计划的)其他交付件一样。</p><p>因此，显然我们需要一个实现POP-2数据类型的组件(我们称其为模块)。以及用于输入和输出这些数据类型的单独组件。以及用于POP-2中缀表达式的词汇和句法分析的模块。</p><p>该计划是将表达式编译成在抽象机上运行的中间语言。所以我们需要编译器和抽象机器解释器的模块。</p><p>然后是用于导出(需求驱动评估)、用于仓库(缓存)、用于仓库存储管理、用于…的模块。不胜枚举。</p><p>在某种程度上，我们意识到我们将处理几十个模块。这听起来可能不是很多，但当你们只有三个人(我、约翰·普莱斯和学生马丁·戴维斯)时就是如此。每一个都应该是可单独编译的，并且都有一个.o文件以保持最新。仅Makefile(S)一项就会很大。</p><p>因此，我们决定将该过程自动化，结果是SLOTH。它消除了makefile，允许单独编译，并使.o文件保持最新。它生成并执行复杂的c编译器命令。这对我们来说非常有效。</p><p>基本思想是让模块成为一个目录(扩展名为.m)，内部包含定义模块的各种文件(例如，过程定义或启动代码)。Sloth将使用这些文件生成自己的文件，并将它们存储在.m目录中。特别是，它将生成并维护最新的.o文件。</p><p>然后，要“编译”一个模块，需要使用“link module”命令LKM。如果foo是一个模块，那么LKM foo将更新foo的.o文件以及foo直接或间接依赖的所有模块的.o文件，启动一个大型编译，并生成一个名为foo的可执行文件。</p><p>通常，最大也是最重要的文件是proc.i文件。它包含过程定义和模块外不需要的其他声明(例如类型声明)。</p><p>模块还有一个var.i文件，其中包含其他模块在模块本身外部所需的变量声明。类似地，对于外部需要的宏、typedefs和其他声明，有一个fine.i文件。</p><p>每个模块都有一个初始化代码的文件体.I，在加电时执行一次。</p><p>在某种意义上，大多数模块需要其他更原始的模块可用。因此，每个模块都有一个文件导入，其中列出了这些模块的名称(不带.m扩展名)。模块不能直接或间接导入自身。</p><p>用户通常不会进入.m目录并直接操作这些文件。相反，它们使用简单的命令：例如，vmdfoo在foo.m目录中显示fine.i文件，而mmpfoo调用编辑器来修改foo.m中的proc.i文件。</p><p>sloth提供用于配置应用程序和生成可执行文件的单个命令。这是LKM(链接模块)命令。调用LKM foo将启动幕后精细计算，并在foo.m内创建许多文件。</p><p>但是，这对用户是透明的。暂停后，LKM终止，并在调用它的目录中保留一个可执行文件foo。</p><p>如果出于好奇心，你想知道懒惰是如何工作的，我建议你参考开头链接的那篇论文。在此期间，我将简要介绍一下(如果不完整的话)。</p><p>第一步是生成由foo直接或间接导入的所有模块的列表；生成可执行foo所需的所有模块。换句话说，这是植根于foo的导入关系的传递闭包。该列表存储在SLOTH生成的USELLIST文件中。</p><p>文件在用户列表中的显示顺序至关重要。简而言之，它首先是最原始的。更准确地说，如果模块X直接导入模块Y，那么Y必须出现在模块X之前(某处)。Sloth通过对导入关系执行拓扑排序来生成uselist。sloth直接或间接计算foo导入的每个文件的使用列表，而不仅仅是foo本身的使用列表。</p><p>下一步是安排foo的用法列表上每个模块的.o文件都是最新的(我将跳过一些细节)。一旦最新的.o文件可用，Sloth就会启动编译，生成可执行文件foo。它创建了一个简短的.c文件，其过程main由对foo的用法列表的powerup例程(body.I文件)的调用组成，最原始的首先调用。最后一个被调用的是Foo本身的第一个Body I.。</p><p>请注意，这不一定涉及大量编译。可能是Uselist上的大多数模块已经具有最新的.o文件，因为它们已经在另一个模块栏的Uselist上，并且已经为其调用了LKM栏。有了SLOTH，应用程序可以共享编译后的代码和源代码。</p><p>早些时候，我们遇到了似乎别无选择，只能允许模块相互导入的情况--这是一种不可接受的情况。在这些情况下，模块A调用模块B中的过程以及模块B调用模块A中的过程似乎是不可避免的。</p><p>考虑从空闲列表中存储分配存储的模块。当空闲列表耗尽时，它会执行标记并清除垃圾收集-这是通常的安排。</p><p>如果模块STA需要动态存储，它显然需要导入sto并调用sto中返回新单元的过程。但另一方面，当空闲列表耗尽时，它需要调用sta中的一个过程，该过程标记sta不准备放弃的所有存储。一个圆形。</p><p>解决方案是将对sta的回调设为匿名，这样sto就不必导入sta。我们向sto提供了我们称为jobjar的东西，即一组函数指针，以及一个将函数指针p添加到作业JAR的过程addjob(P)。在sta的powerup代码中，我们调用addjob(P)，其中p是指向标记存储STA要保留的函数的指针。</p><p>然后，当自由列表用完时，sto首先标记它知道的所有信息，然后遍历作业JAR，调用其中的所有过程。这标记了导入sto的所有模块所需的所有存储空间(假设它们在初始化时都根据需要调用了addjob)。</p><p>类似的情况多次出现。例如，假设模块mch实现抽象机。机器的工作原理是将程序与POP-2单词相关联，在表格中将单词与函数指针配对。例如，如果模块MAT执行矩阵命令，则MAT导入mch。但机器必须知道矩阵命令及其名称。</p><p>解决方案是向MCH提供过程NEW COMMAND(W，P)，该过程NEW COMMAND(W，P)接受字W和函数指针P，并将W添加到与P相关联的命令表。MAT中的POWER UP代码将所有MAT命令添加到MCH中的指令表。</p><p>懒惰最初是为了配置Pascal(！)。代码，直到我们意识到没有办法实现可扩展模块，因为Pascal没有等价的函数指针。</p><p>有一个版本的Sloth，称为Lemur，它处理版本控制，但我将在稍后描述它。</p><p>懒惰是可用的，如果你们中的任何人在博客上认为这可能是有用的。它目前没有被使用或维护，但是我们有标准C的源代码(不，我们没有愚蠢到把它结构成Sloth模块)。懒惰模块不如Python模块方便。Python模块具有大多数相同的功能(例如，按正确的顺序导入模块)，没有第三方应用程序带来的不便。开发懒惰换Python是没有意义的。</p><p>另一方面，信不信由你，C语言仍然被广泛使用，如果你正在使用它，你会想要模块化。也许斯劳思可以帮助你把几十年前的技术更新几十年。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://billwadge.wordpress.com/2020/06/23/the-sin-of-sloth-an-external-module-system-for-c/">https://billwadge.wordpress.com/2020/06/23/the-sin-of-sloth-an-external-module-system-for-c/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sloth/">#sloth</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模块/">#模块</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1007138.html"><img src="http://img.diglog.com/img/2020/6/thumb_7583c582a09ba5fcac7604ae2baefec2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1007138.html">编译时合并排序[C++]</a></div><span class="my_story_list_date">2020-6-19 2:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1006626.html"><img src="http://img.diglog.com/img/2020/6/thumb_d53626a3377af2a71b755e39ee7e3311.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1006626.html">一个简单的图形用户界面记事本，使用C++在2015年我的高中原生制造</a></div><span class="my_story_list_date">2020-6-15 14:7</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005511.html"><img src="http://img.diglog.com/img/2020/6/thumb_29f7802725a77f3ec5349cd059cd94e4.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005511.html">SpaceX如何使用Linux、Chromium、C++和开源库</a></div><span class="my_story_list_date">2020-6-7 7:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005422.html"><img src="http://img.diglog.com/img/2020/6/thumb_c33efa1719f6fe3b3c05c1ecc94254fc.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005422.html">cingulata：在具有完全同态加密的加密数据上运行C++代码</a></div><span class="my_story_list_date">2020-6-6 18:16</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>