<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在阿森西奥等待</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在阿森西奥等待</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-23 13:44:14</div><div class="page_narrow text-break page_content"><p>使用asyncio的主要吸引力之一是能够发出多个协同例程并同时运行它们。你知道有多少种方法可以等待他们的结果？</p><p>他们有相当多的人！然而，不同的方式有不同的属性，它们都值得拥有自己的位置。不过，我经常得查一查才能找到合适的。</p><p>协程：正在运行的异步函数。因此，如果将函数定义为异步def()：.。把它称为f()，你会得到一个协程，在这个意义上，这个术语在这篇文章中一直在使用。</p><p>可等待：任何可以与等待一起工作的东西：协程、异步.Futures、异步.Tasks、具有__Await__方法的对象。</p><p>在我的示例中，我将使用两个异步函数f和g。它们做什么并不重要，重要的是它们被定义为异步def()：.。和Async def g()：.。他们最终会终止。</p><p>但是g/coro_g的执行在等待之前不会开始，这使得它与第一个示例完全相同。对于这两个问题，您需要将协程封装在任务中。</p><p>Asyncio.Tasks包装协程，并在您将控制权交给它时由事件循环独立调度执行2.您可以使用asyncio.create_task()创建它们：</p><p>task_f=asyncio.create_task(f())task_g=asyncio.create_task(g())等待异步。睡眠(0.1)#&lt；-f()和g()已在运行！result_f=等待任务_fresult_g=等待任务g</p><p>您的任务现在并发运行，如果您决定不想等待task_f或task_g完成，可以分别使用task_f.ancel()或task_g.ancel()取消它们。请注意，您必须在等待第一个任务之前创建这两个任务-否则您将一无所获。然而，等待只需要收集结果和清理资源3。</p><p>但是像这样等他们每个人都是不太现实的。在实际的代码中，您经常甚至不知道需要争论多少个等待项。我们需要的是收集多个等待的结果。</p><p>asyncio.ather()将1个或多个等待项作为*args，必要时将它们包装在任务中，然后等待它们全部完成。然后，它返回所有等待项的结果，顺序与您传入等待项的顺序相同：</p><p>如果f()或g()引发异常，Gather()将立即引发该异常，但其他任务不受影响。但是，如果Gather()本身被取消，它正在收集的所有等待项-以及尚未完成的等待项-也都会被取消。</p><p>您还可以传递RETURN_EXCEPTIONS=True，然后像正常结果一样返回异常，并且您必须检查自己是否成功(例如，使用isInstance(Result，BaseException))。</p><p>以相同顺序返回结果列表。否则，如果其中一个等待对象引发异常，Gather()会立即将其传播给调用方。但其余任务仍在运行。</p><p>现在我们可以同时等待许多等待的东西了！但是，行为良好的分布式系统需要超时。由于gather()没有这样的选项，我们需要下一个帮助器。</p><p>waitfor()接受两个参数：一个是可等待的，另一个是超时(以秒为单位)。如果可等待对象是协程，则它将自动由任务包装。因此，下面的构造非常常见：</p><p>try：result_f，result_g=await asyncio.wait_for(asyncio.ather(f()，g())，timeout=5.0。)除异步外。超时错误：打印(&#34；oops耗时超过5s！&#34；)。</p><p>如果超时到期，内部任务将被取消。这对于Gather()意味着它正在收集的所有任务也被取消：在本例中是f()和g()。</p><p>请注意，仅将create_task()替换为wait_for()并将其称为一天是行不通的。create_task()是返回任务的常规函数；wait_for()是返回协程的异步函数。这意味着在您等待它之前，它不会开始执行：</p><p>#NOT CURRENT！cf=asyncio.wait_for(f()，timeout=0.5)cg=asyncio.wait_for(g()，timeout=0.5)#cf和cg都是COROUTINES，而不是任务！#此时，事件循环没有任何计划。等待cf#g()尚未执行！等待cg#wait_for在这里仅为g()创建任务。</p><p>如果您现在认为如果Gather()有一个超时选项，就不需要waitfor()，那么我们也是这么想的。</p><p>一种更优雅的超时方法是PyPI上的异步超时软件包。它为您提供了一个异步上下文管理器，允许您应用总超时，即使您需要按顺序执行协程：</p><p>有时候，你不想等到所有的等待都做完了。也许您希望在它们完成时对其进行处理，并向用户报告某种进度。</p><p>asyncio.as_Complete()获取可迭代的4个等待项，并返回一个迭代器，该迭代器按照等待项完成的顺序生成asyncio.Futures：</p><p>对于Asyncio.as_Complete([task_f，task_g]，timeout=5.0)中的FUT：尝试：等待FUT打印(&#34；一个任务关闭！&#34；)例外：打印(&#34；哎呀&#34；)。</p><p>没有办法知道你在等待的是哪一个，尽管是5点。</p><p>最后，您可能需要对等待进行更多的控制，这将我们带到最后的等待原语。</p><p>wait()是API中最笨重的，但也是功能最强大的。它有点让人想起古老的select()系统调用。</p><p>与as_Complete()类似，它接受迭代量中的可等待变量。它将返回两个集合：已完成的等待项和仍在等待的项。这取决于你是否等待他们，并决定哪个结果属于什么：</p><p>Done，Pending=Await asyncio.Wait([task_f，task_g])for t in Done：try：if t is task_f：print(f&#34；f()的结果是{await task_f}.&#34；)异常除外，因为e：print(f&#34；f()失败，出现{repr(E)}.&#34；)#.，g()也是如此。</p><p>如果传入协例程并使用wait()将其封装在任务中，则此代码将不起作用，因为返回的等待对象将不同于您传入的等待对象，并且身份检查总是失败7。目前，wait()无论如何都会这样做，但它会警告您，因为它可能是一个bug。</p><p>您可以传递一个超时，在此之后Wait()将返回。与gather()不同的是，当超时到期时不会对等待对象执行任何操作。该函数只返回任务并将其排序到Done和Pending存储桶中。</p><p>您可以使用RETURN_WHEN参数告诉wait()不要等到所有等待事项都完成之后。默认情况下，它被设置为asyncio.ALL_COMPLETED，其功能与听起来完全一样。但您也可以将其设置为asyncio.FIRST_EXCEPTION，它也会等待所有等待对象完成，除非其中一个引发异常-然后它将使其立即返回。最后，asyncio.FIRST_COMPLETED返回任何等待项完成的时刻。</p><p>所有这些加在一起有点复杂，但是允许您构建强大的调度程序函数。通常使用WHILE循环，直到完成所有等待。</p><p>将不返回结果，但传递的等待项被排序为两个集，它们作为(Done，Pending)的元组返回。这取决于你的等待和派遣。</p><p>将包含任务，但会就此发出警告，因为这意味着您得到的等待项与您放入的不同。避免并且只通过任务！</p><p>在应该将任务排序到存储桶中并返回时为您提供细粒度的控制-它从不取消任何任务：传递一个return_When with：asyncio.FIRST_EXCEPTION：一旦所有任务都完成，或者一旦引发异常。</p><p>在所有可用的异步材料中，我只知道有两套内容全面、准确，而且是由具有丰富异步实践经验的人撰写的：</p><p>Łukasz langa在facebook和instagram做过大量的异步操作，现在为edgeDB(一个广泛使用异步操作的数据库)工作，他开始了一个视频系列，从无到有，一直发展到异步操作。第三集与本文特别相关，因为它展示了asyncio.wait()的实际用法。</p><p>对于更高级的异步生产建议，Spotify的林恩·鲁特(Lynn Root)就这个主题做了两次演讲：异步实践：我们做错了(2018年)和高级异步：解决现实世界生产问题(2019年)，并提供了大量的书面教程。</p><p>如果您不使用所有的结果和异常，Asyncio将会抱怨。↩︎。</p><p>有漏洞，但它们很难看，而且依赖于未记录的实现细节。↩︎。</p><p>由于Done存储桶中的结果是可以保证完成的，因此您还可以使用Task.result()和Task.ception()检查它们的结果。但我发现等待他们更加得体。↩︎。</p><p>因为waitfor()返回协程，所以这也非常适用于它！除非将waitfor()调用包装到任务中，否则这两个函数不能混合。↩︎。</p><p>我的内容对你有帮助和/或有趣吗？请考虑表达你的感激之情！每一点都有助于激励我创作更多内容。你也可以在Ko-fi上给我买一杯咖啡-3欧元起，不需要账户。</p><p>如果你会说德语，请考虑从我的雇主Variomedia处获得你的域名和虚拟主机。如果没有他们的支持，我的社区产出将会相当少。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hynek.me/articles/waiting-in-asyncio/">https://hynek.me/articles/waiting-in-asyncio/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/阿森/">#阿森</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/waiting/">#waiting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/等待/">#等待</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>