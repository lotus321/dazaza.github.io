<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>常见的锈蚀寿命误区</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">常见的锈蚀寿命误区</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-23 15:14:02</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/5/88fd6ddb8253d4481c2e73bf9c8b9c36.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>我曾经在某种程度上持有所有这些误解，今天我看到许多初学者都在与这些误解作斗争。我的一些术语可能不是标准的，所以这里有一张我使用的速记短语的表格，以及我想要表达的意思。</p><p>简而言之：变量的生存期是编译器可以静态验证它所指向的数据在其当前内存地址有效的时间长度。我现在将用接下来的6000个单词更详细地介绍人们通常会感到困惑的地方。</p><p>这种误解更多的是关于泛型，而不是生存期，但是泛型和生存期在铁锈中紧密交织在一起，所以谈到其中一个而不谈到另一个是不可能的。不管怎么说：</p><p>当我第一次开始学习Rust时，我知道I32、&amp；I32和&amp；mut I32是不同的类型。我还理解一些泛型类型变量T表示包含所有可能类型的集合。然而，尽管我把这两件事分开理解，我还是不能把它们放在一起理解。在我的新手Rust头脑中，我认为泛型是这样工作的：</p><p>%t包含所有拥有的类型。&amp；T包含所有不变的借用类型。&amp；mut T包含所有可变借用类型。T、&amp；T和&amp；mut T是不相交的有限集。漂亮，简单，干净，轻松，直观，完全错误。下面是泛型在Rust中的实际工作方式：</p><p>T、&amp；T和&amp；mut T都是无限集合，因为可以借用ad-infinitum类型。T是&amp；T和&amp；mut的超集。&amp；T和&amp；mut T是不相交的集合。这里有几个例子来验证这些概念：</p><p>&amp；T{}的特征特征{}实施&lt；T&&gt;；特征(&amp；t；T&&gt;；特征)&amp；T；T&&gt;；特征(&amp；t；T&&gt;；特征)编译错误(&amp；mut；T&&gt;；T&&gt;；特征)(&amp；mut T{})//编译错误。</p><p>错误[E0119]。mut_`：--&gt；src/lib.rs：7：1|3|为T{}实施&lt；T&gt；特征|-第一个实现在此.。7|实施&amp；mut T{}的T&gt；特征|^`冲突的`&amp；mut_`实现</p><p>编译器不允许我们定义&amp；T和&amp；mut T的特征实现，因为这将与已经包括所有&amp；T和&amp；mut T的特征实现冲突。以下程序按预期进行编译，因为&amp；T和&amp；mut T是不相交的：</p><p>特征特征{}实施&amp；T&&gt;；特征{}//编译&amp；mut T{}//实施&lt；T&&gt;；特征。</p><p>大多数Rust初学者都是在如下代码示例中第一次了解静态生存期的：</p><p>他们被告知，字符串文字被硬编码到编译后的二进制文件中，并且在运行时加载到只读存储器中，因此它是不可变的，并且对整个程序有效，这就是它是静态的。围绕使用static关键字定义静态变量的规则进一步强化了这些概念。</p><p>静态字节：[U8；3]=[1，2，3]；静态mut_bytes：[U8；3]=[1，2，3]；fn main(){mut_bytes[0]=99；//编译错误，变异静态不安全{mut_bytes[0]=99；assert_eq！(99，mut_bytes[0])；}}。</p><p>静态生存期可能是以静态变量的默认生存期命名的，对吗？因此，静态生存期必须遵循所有相同的规则是有道理的，对吗？</p><p>是的，但是具有静态生存期的类型与以静态生存期为界限的类型是不同的。后者可以在运行时动态分配，可以安全自由地变异，可以删除，并且可以存活任意持续时间。</p><p>静态T是对某些T的不可变引用，这些T可以安全地无限期地保持很长时间，包括直到程序结束。只有当T本身是不可变的，并且在创建引用后不会移动时，这才是可能的。t不需要在编译时创建。有可能在运行时生成随机的动态分配的数据，并返回对它的静态引用，代价是内存泄漏，例如</p><p>使用rand；//在运行时生成随机静态字符串引用fn rand_str_Generator()-&gt；&amp；&#39；静态字符串{let rand_string=rand：：Random：：&lt；U64&gt；()。to_string()；Box：：Leak(rand_string。into_boxed_str())}。</p><p>T：&#39；Static是一些T，它可以安全地无限期地保持很长时间，包括直到程序结束。T：&#39；static包括所有&amp；&amp；static T，但它也包括所有拥有的类型，如String、Vec等。某些数据的所有者可以保证，只要所有者持有数据，数据就永远不会失效，因此所有者可以安全地无限期地持有数据，包括直到程序结束。T：&#39；静态应理解为&#34；T由&#34；静态生存期限定，而不是&#34；T具有&#34；静态生存期。帮助说明这些概念的程序：</p><p>使用rand；fn drop_static&lt；T：&#39；static&gt；(t：t){std：：mem：：drop(T)；}fn main(){let mut string：vec&lt；string&gt；=vec：：new()；for_in 0.。10{if rand：：Random(){//所有字符串都是随机生成的//并在运行时动态分配，让string=rand：：Random：：&lt；U64&gt；()。to_string()；字符串。Push(String)；}//字符串是拥有的类型，因此它们由字符串中mut字符串的静态约束{//所有字符串都是可变字符串。PUSH_STR(&#34；a突变&#34；)；//所有字符串都是可丢弃的DROP_STATIC(字符串)；//编译}//程序结束前所有字符串都已失效println！(&#34；我是程序的结尾&#34；)；}。</p><p>如果T：静态，则T可以是具有静态生存期的借用类型或拥有类型。</p><p>&amp；A T需要并暗示T：&#39；a，因为如果T本身对&#39；a无效，则对生命周期&a的引用不能对&#39；a有效。例如，Rust编译器永远不允许构造类型&amp；static Ref&lt；&#39；a，因为如果引用仅对&#39；a有效，我们就不能使&#39；a成为静态类型。</p><p>//仅采用&#39；a，t：&#39；a，T：&#39；a&gt；(t：&amp；&39；a){}//以&#39；fn t_bound&lt；&#39；a，T：&#39；a&gt；(t：t){}//所拥有的包含引用结构的类型为边界的ref类型(&#39；a_ref&lt；&#39；a，T：&#39；a&gt；(t：t){}//包含引用结构的fn t_bound&lt；(t：t){}//拥有的类型包含引用结构。a&gt；(&amp；#39；a T)；fn main(){let string=string：：from(&#34；string&#34；)；t_Bound(&amp；string)；//编译t_Bound(Ref(&amp；string))；//编译t_Bound(&amp；Ref(&amp；String))；//编译t_ref(&amp；string)；//编译t_ref(Ref(&amp；String))；//编译t_ref(&amp；string)；//编译t_ref(&amp；string。//编译错误，预期的ref，找到struct t_ref(&amp；Ref(&amp；string))；//编译//字符串变量由&#39；a t_bound(String)；//编译}。</p><p>多亏了Rust的生存期省略规则，这个令人欣慰的误解得以保留，它允许您省略函数中的生存期注释，因为Rust借入检查器将按照以下规则推断它们：</p><p>如果存在多个输入生存期，但其中之一是&amp；self或&amp mut self，则self的生存期将应用于所有输出引用</p><p>//elided FN打印(s：&amp；str)；//扩展FN打印(s：&amp；&39；a&gt；(s：&amp；&#39；a str)；//elid FN trim(s：&amp；str)-&gt；&amp；str；//扩展FN trim&lt；&39；a&gt；(s：&amp；&39；a str)-&gt；&amp。//非法，无法确定输出寿命，没有输入fn get_str()-&gt；&amp；str；//显式选项包括fn get_str；()-&gt；&amp；&39；a str；//毫无意义的泛型，因为&#39；a必须等于&#39；static fn get_str()-&gt；&amp；&39；static str。//更好、更明确//非法，无法确定输出寿命，多个输入fn重叠(s：&amp；str，t：&amp；str)-&gt；&amp；str；//显式(但仍部分省略)选项包括fn重叠&lt；&39；a&gt；(s：&amp；&39；a str，t：&amp；str)-&gt；&amp；a str；/。t超出fn重叠&lt；a&gt；(s：&amp；str，t：&amp；&39；a str)-&gt；&amp；a str；//输出不能超过fn重叠&lt；&39；a&gt；(s：&amp；a str，t：&amp；a str)-&gt；&amp。//输出可以超过s&amp；t FN重叠(s：&amp；str，t：&amp；str)-&gt；&amp；&39；静态str；//输出可以超过s&amp；t FN重叠&lt；&39；a&gt；(s：&amp；str，t：&amp；str)-&&gt;&amp；&amp；a str；//输入和amp；之间没有关系。&#39；a，&#39；b&&gt;(s：&amp；a str，t：&amp；&39；b str)-&gt；&amp；&amp；&#39；a，&#39；b&&gt;(s：&amp；&39；a str，t：&amp；&39；b str)-&gt；&amp；&#39；b。fn重叠&lt；a&gt；(s：&amp；a str，t：&amp；a str)-&gt；&amp；a str；fn重叠&lt；a，&#39；b&gt；(s：&amp；&39；a str，t：&amp；&39；b str)-&gt；&amp；&39；&#39；a，&#39；b，&#39；c&&gt;；(s：&amp；&39；a str，t：&amp；&#39；b str)-&gt；&amp；&#39；c str；//省略FN比较(&amp；self，s：&amp；str)-&gt；&amp；&amp；str；//扩展的fn比较&lt；a，&39；b&gt。&#39；a Self，&amp；&b str)-&gt；&amp；a str；</p><p>Rust程序有可能在技术上是可编译的，但在语义上仍然是错误的。以此为例：</p><p>struct ByteIter&lt；&#39；a&&gt;；{剩余部分：&amp；&39；a[U8]}实施&lt；&#39；a；ByteIter&lt；{fn Next(&amp；mut self)-&gt；option&lt；&amp；U8&&gt;；{如果自我保留。is_Empty(){None}Else{let byte=&amp；self.reminder[0]；self.reminder=&amp；self.remindance[1..]；Some(Byte)}fn main(){let mut bytes=ByteIter{Remainder：B&#34；1&#34；}；assert_eq！(Some(&amp；b&#39；1&#39；)，bytes。next())；assert_eq！(无，字节。Next())；}。</p><p>ByteIter是迭代字节切片的迭代器。为简洁起见，我们将跳过迭代器特征实现。它似乎工作得很好，但是如果我们想一次检查几个字节怎么办？</p><p>fn main(){设mut bytes=ByteIter{剩余部分：B&#34；1123&#34；}；设byte_1=字节。Next()；设byte_2=字节。Next()；如果byte_1==byte_2{//做点什么}}。</p><p>错误[E0499]：不能一次将`bytes`作为可变变量多次借用--&gt；src/main.rs：20：18|19|let byte_1=bytes。Next()；|-第一个可变借入出现在这里20|let byte_2=bytes。Next()；|^第二次可变借入出现在此处21|If BYTE_1==BYTE_2{|-这里稍后使用的第一次借入。</p><p>我想我们可以复制每个字节。当我们正在处理字节时，复制是可以的，但是如果我们将ByteIter转换为可以迭代任何[T]的泛型切片迭代器，那么我们可能希望在将来将其用于可能非常昂贵或不可能复制/克隆的类型。哦，好吧，我想我们对此无能为力，代码会编译，所以生存期注释一定是正确的，对吗？</p><p>不，当前的生存期注释实际上是错误的来源！它特别难被发现，因为错误的生命周期注释被省略了。为了更清楚地了解问题，让我们延长已取消的生命周期：</p><p>struct ByteIter&lt；&#39；a&&gt;；{剩余部分：&amp；&39；a&&gt;}实施&lt；&#39；a&&gt;；字节项&lt；{FN Next&lt；&#39；b&&gt;(&amp；#39；b mut Self)-&&gt;选项&lt；&amp；b U8&&gt;t；{FN Next&lt；(&amp；#39；b MUT Self)-&&gt;选项&lt；&amp；b U8&&gt;t；{FN Next&lt；(&amp；#39；b MUT Self)-&&gt;选项&lt；&amp；b U8&&gt;。IS_EMPTY(){NONE}ELSE{let byte=&amp；self.reminder[0]；self.reminder=&amp；self.reminder[1..]；ome(Byte)}。</p><p>那一点帮助都没有。我还是很困惑。这里有一个只有铁锈专家才知道的热点提示：给你的终身注释起描述性的名字。让我们重试：</p><p>结构字节项目&#39；剩余部分&&gt;；{剩余部分：&amp；#39；剩余部分[U8]}实施&lt；&#39；剩余部分；字节项&lt；&#39；剩余部分&&gt;{FN NEXT&lt；&#39；MUT_SELF&&gt;(&amp；&39；MUT_Self MUT SELF)-&&gt;选项&lt；&amp；&39；IS_EMPTY(){NONE}ELSE{let byte=&amp；self.reminder[0]；self.reminder=&amp；self.reminder[1..]；ome(Byte)}。</p><p>每个返回的字节都带有&#39；mut_self注释，但是这些字节显然来自&#39；RELENDER！让我们把它修好。</p><p>结构字节项&lt；&#39；剩余&&gt;；{剩余部分：&amp；&#39；剩余部分[U8]}实施&lt；&#39；剩余部分&lt；&#39；剩余部分&&gt;{fn Next(&amp；mut self)-&&gt;选项&lt；&amp；&amp；&#39；剩余部分U8&&gt;{如果自我保留。is_Empty(){None}Else{let byte=&amp；self.reemainth[0]；self.reminder=&amp；self.remindance[1..]；Some(Byte)}fn main(){let mut bytes=ByteIter{RELEMENT：B&#34；1123&#34；}；let byte_1=bytes。Next()；设byte_2=字节。Next()；std：：mem：：drop(Bytes)；//我们现在甚至可以删除迭代器！如果BYTE_1==BYTE_2{//编译//执行某些操作}}。</p><p>现在我们回过头来看我们程序的前一个版本，它显然是错误的，那么为什么Rust要编译它呢？答案很简单：它是内存安全的。</p><p>Rust借入检查器只关心程序中的生存期注释，只要它可以使用它们来静态验证程序的内存安全性。即使生命周期注释有语义错误，Rust也会愉快地编译程序，其结果是程序变得不必要的限制。</p><p>这里是一个与前一个示例相反的快速示例：在这个实例中，Ruust的生存期省略规则碰巧在语义上是正确的，但是我们无意中用我们自己不必要的显式生存期注释编写了一个非常有限制性的方法。在这种情况下，Ruust的生存期省略规则在语义上是正确的，但是我们无意中用自己不必要的显式生存期注释编写了一个非常严格的方法。</p><p>#[Derive(Debug)]struct NumRef&lt；&#39；a&gt；(&amp；#39；a I32)；Iml&lt；&#39；a；NumRef&lt；&#39；a&&gt;{//my struct是&#39；a上的泛型结构，这意味着我也需要用&#39；a注释//我的self参数，对吗？(回答：不，不正确)fn ome_method(&amp；&#39；a mut self){}}fn main(){let mut num_ref=NumRef(&amp；5)；num_ref。SomeMethod()；//可变地借用num_ref作为其剩余生命周期的num_ref。Some_Method()；//编译错误println！(&#34；{：？}&#34；，num_ref)；//也编译错误}。</p><p>如果我们在&#39；a上有一些结构泛型，我们几乎永远不会想要编写一个带有mut自身接收器的方法。我们正在向Rust传达的是，此方法将在结构的整个生命周期内可变地借用结构。实际上，这意味着Rust的借入检查器在结构变为永久可变借入从而不可用之前，最多只允许调用一次某些方法。这方面的用例极其罕见，但是上面的代码对于困惑的初学者来说非常容易编写，并且可以编译。修复方法是不添加不必要的显式生存期注释，并让Rust的生存期省略规则处理：</p><p>#[派生(调试)]struct NumRef&lt；&#39；a&gt；(&amp；#39；a I32)；实施&39；a；NumRef&lt；&#39；a&&gt;a on mut self FN SOME_METHOD(&amp；MUT Self){}//以上行对FN SOME_METHOD_Desugared&lt。b mut self){}}fn main(){let mut num_ref=NumRef(&amp；5)；num_ref.。某些方法()；num_ref。Some_Method()；//编译println！(&#34；{：？}&#34；，num_ref)；//编译}。</p><p>前面我们讨论了Rust的函数生命周期省略规则。Ruust还具有特征对象的生存期省略规则，其中包括：</p><p>如果将特征对象用作泛型类型的类型参数，则从包含类型推断其生存期界限。如果从包含类型有多个界限，则必须指定显式界限。</p><p>如果上述条件不适用，则如果特性定义为具有单个生命周期界限，则使用该界限。</p><p>如果特征没有生存期界限，则其生存期在表达式中推断，并且在表达式之外是静态的。</p><p>所有这一切听起来超级复杂，但可以简单地概括为特征对象的生命周期界限是从上下文中推断出来的。在看了几个例子之后，我们会发现生命周期界限的推论非常直观，所以我们不需要记住形式规则：</p><p>使用std：：cell：：ref；特征特征{}//省略类型T1=Box&lt；dyn特征&gt；；//展开，Box&lt；T&gt；对T没有生存期限制，因此推断为&#39；静态类型T2=Box&lt；dyn特征+&#39；静态&gt；；//省略实施动态特征{}//扩展实施动态特征+&#39；静态{}//省略类型T3。动态特征；//扩展的T需要T：&#39；a，因此推断为&#39；a类型T4&gt；=&amp；#39；a(动态特征；a)；//省略类型T5&lt；&39；a&&gt;；=Ref&lt；a，Dyn特征&&gt;；//扩展，参考。需要T：&#39；a，因此推断为&#39；a类型T6&lt；&#39；a&&gt;；=Ref&lt；&#39；a，dyn特征；特性GenericTrait&lt；&#39；a&&gt;；：&#39；a{}//省略类型T7&lt；&#39；a&&gt;；=Box&lt；a&&gt;；=Box&lt；a&gt；=Box&lt；a&&gt;；&#39；a&&gt;=Box&lt；dyn GenericTrait&lt；&#39；a&gt；dyn GenericTrait&lt；&#39；a&gt；</p><p>实现特征的具体类型可以有引用，因此它们也有生存期界限，因此它们对应的特征对象也有生存期界限。此外，您还可以直接为引用实现特征，这显然是有生命周期限制的：</p><p>特征{}struct Struct{}struct Ref&&gt;；(&amp；&39；T&&gt;；(&amp；；a T)；对结构{}实施特征对&amp；Struct{}//对引用类型实施特征直接对引用类型实施特征；对类型实施特征(&amp；A，T&&gt;；{}//对引用类型实施特征)，T&&gt;；(&amp；A，T&&gt;；(&amp；a)；(&amp；a)；直接在引用类型上实施特征(&amp；Struct{})//实施特征(&amp；Struct{}//Iml Struct{}//Iml Characteristic)。</p><p>无论如何，这是值得复习的，因为当初学者将函数从使用特征对象重构到泛型(反之亦然)时，这常常会让他们感到困惑。以此程序为例：</p><p>使用std：：fmt：：display；fn dynamic_thread_print(t：box&lt；dyn display+send&gt；){std：：thread：：spawn(Move||{println！(&#34；{}&#34；，t)；})。Join()；}fn static_thread_print&lt；T：display+send&gt；(t：t){std：：thread：：spawn(Move||{println！(&#34；{}&#34；，t)；})。Join()；}。</p><p>错误[E0310]：参数类型`T`可能存在时间不够长--&gt；src/lib.rs：10：5|9|fn static_thread_print&lt；T：display+send&gt；(t：t){|--help：考虑添加明确的生存期限制.：`t：&#39；static+`10|std：：Thread：：SPAWN(移动||{|^}类型`[Close@src/lib.rs：10：gt；src/lib.rs：10：5|10|std：：Thread：：Spawn(移动||{|^。</p><p>好的，很好，编译器告诉我们如何解决这个问题，所以让我们来解决这个问题。</p><p>使用std：：fmt：：display；fn dynamic_thread_print(t：box&lt；dyn display+send&gt；){std：：thread：：spawn(Move||{println！(&#34；{}&#34；，t)；})。Join()；}fn static_thread_print&lt；T：display+send+&#39；static&gt；(t：t){std：：thread：：spawn(Move||{println！(&#34；{}&#34；，t)；})。Join()；}</p><p>它现在可以编译，但是这两个函数看起来彼此相邻不方便，为什么第二个函数需要一个&#3。</p><p>..</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寿命/">#寿命</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1003370.html"><img src="http://img.diglog.com/img/2020/5/thumb_ec41b1bbfd64dc582c0b7f3673332500.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003370.html">微软：这就是我们热爱编程语言Rust并启动维罗纳项目的原因</a></div><span class="my_story_list_date">2020-5-23 13:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002706.html"><img src="http://img.diglog.com/img/2020/5/thumb_92ffcc35d5ca44c6ecefe7c8c3fc3dc7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002706.html">Facebook收购Giphy在国会敲响了反垄断警报</a></div><span class="my_story_list_date">2020-5-19 6:52</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002565.html"><img src="http://img.diglog.com/img/2020/5/thumb_1d220eb57b5e6521df6829fadc8b94d5.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002565.html">Rust/WinRT使微软更接近在内部采用Rust</a></div><span class="my_story_list_date">2020-5-18 4:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002362.html"><img src="http://img.diglog.com/img/2020/5/thumb_467d0d52a10a5d84b2cd114f7198ad59.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002362.html">POI：Rust中的实用无点定理证明器助手</a></div><span class="my_story_list_date">2020-5-16 14:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>