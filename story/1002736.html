<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么NetNewsWire速度快</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">为什么NetNewsWire速度快</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-19 12:03:13</div><div class="page_narrow text-break page_content"><p>NetNewsWire之所以速度快，是因为性能是我们的核心价值之一。快速是这款应用程序定义的一部分。</p><p>我怀疑用其他任何方式都很难做到这一点。如果你花一两个月的时间来加快速度，有时，你的应用程序总是-充其量也就是-只是朝着令人满意的方向前进，但永远不会到来。</p><p>我能给出的最好的一般性建议就是：确保性能是你的应用程序基础的一部分。确保这是每天每个决定的一部分。</p><p>换句话说，要确保这场表演不仅仅是一种配料，而是披萨。</p><p>以下是NetNewsWire速度快的一些具体原因。因为NetNewsWire-就像现在的许多应用程序一样-基本上是一个花哨的数据库浏览器，数据来自网络，其中一些将适用于其他应用程序。</p><p>解析XML最痛苦的方法是使用SAX解析器-但这也是获得最佳性能和使用最少内存的方法。因此，我们在RSParser框架中使用SAX。</p><p>在我的2012iMac上，解析Dling Fireball Atom feed的一些过去实例的本地副本-大小相对较大，为112K-发生在0.009秒内。</p><p>这很快，但我们还做了另一件事：在后台对串行队列运行解析器。由于解析是一个自包含的操作-我们输入一些数据并取回对象-因此不存在线程问题。</p><p>解析器速度很快-但我们也会尽最大努力在可能的情况下完全跳过解析。我们有两种方法可以做到这一点。</p><p>我们使用条件GET，这使服务器有机会在提要自我们上次请求后没有更改时使用304 NOT MODIFIED和NO CONTENT进行响应。显然，我们在这种情况下跳过了解析。</p><p>每当我们下载提要时，我们还会创建原始提要内容的散列。如果散列与上次的散列匹配，那么我们知道内容没有被修改，我们跳过解析。</p><p>解析器不是我们在串行队列上运行的唯一代码。当一个操作可以成为自包含的-当它可以只做一件事，然后回调到主线程时，没有线程问题-如果有任何机会明显阻塞主线程，我们就使用串行队列。</p><p>当然，关键是要确保您的操作实际上是独立的。他们在工作时不应该触发KVO或其他类型的通知。</p><p>(除了提要解析之外，背景的一个简单示例是创建提要图标的缩略图。)。</p><p>这里有一个很容易落入陷阱的例子。假设用户正在将一篇文章标记为已读。通过KVO或通知或其他方式调用文章.read=true触发数据库更新、用户界面更新、未读计数更新、撤消堆栈维护等。</p><p>现在，假设您正在将当前时间线中的所有文章标记为已读。您可以为每一篇文章调用titile.read=true，并为每一篇文章触发一大堆工作。这可能会非常非常慢。</p><p>对于这样的操作，我们有特定的API，而这些API需要一个对象集合。将一篇文章标记为已读的API与将10,000篇文章标记为已读的API相同。这样，数据库更新一次，未读计数更新一次，我们只在撤消堆栈上推入一个操作。</p><p>我们还努力把其他种类的工作结合起来。例如，在刷新期间，应用程序可以重新计算每一次更改的未读计数，但这可能意味着大量的工作。</p><p>因此，取而代之的是，我们将这些合并在一起-我们这样做是为了使重新计算未读计数的频率不超过每0.25秒一次(例如)。这可能会带来巨大的不同。</p><p>对于一个同样只是一个花哨的数据库浏览器的应用程序来说，这是整个事情成败的关键所在。</p><p>虽然核心数据很棒，但我们通过FMDB更直接地使用SQLite，因为这使我们能够将数据库视为数据库。我们可以通过核心数据范围之外的方式优化我们的架构、索引和查询。(请记住，Core Data管理对象图：它不是数据库。)。</p><p>我们使用各种工具-例如解释查询计划-来确保我们已经快速高效地进行了提取、计数和更新。</p><p>我们自己做缓存。我们在串行队列上运行数据库，因此不会阻塞主线程。对于模型对象，我们尽可能使用结构而不是类。(不确定这对性能是否重要：我们只是碰巧喜欢结构。)。</p><p>我可以，也许应该在这里写更多详细的文章。数据库工作是NetNewsWire速度最快的原因。</p><p>我们经常需要查找东西-例如，给定feed的feed ID-，因此我们经常使用字典。这在Mac和iOS编程中相当常见。</p><p>我怀疑不太常见的是套装的使用。Set是我们的默认集合类型--我们永远不想检查数组是否包含某些内容，也不想处理重复的对象。这些可能是性能杀手。</p><p>当某些API需要数组或需要有序集合(通常用于UI)时，我们使用数组。</p><p>我们使用Instruments中的分析器来准确地找出什么是慢的，而不是猜测什么是慢的。</p><p>分析器经常令人惊讶！我们发现有一件事是我们没有预料到的：散列我们的一些对象一度相当慢。</p><p>因为我们经常使用集合，所以进行了大量的散列操作。我们在一些具有大量字符串属性的对象上使用合成的等价性和哈希性-而且，事实证明，对字符串进行散列相当慢。</p><p>因此，我们为这些对象编写了我们自己的散列函数。在许多情况下，我们可以只散列一个字符串属性-例如，一个文章ID-而不是五个、十个或更多。</p><p>我使用堆栈视图的经验告诉我，它们非常慢。他们只是不被允许。</p><p>当人们称赞NetNewsWire这样的基于时间轴的应用程序时，他们通常会说“它像黄油一样滚动！”(我认为黄油实际上根本不能很好地滚动，但是，是的，我知道黄油是光滑的。)。</p><p>虽然我们大量使用Auto Layout(自动布局)--它很酷，而且我们很喜欢--但我们不允许在表格单元格视图中使用它。相反，我们编写自己的布局代码。</p><p>这其实并不难。也许有点单调乏味，但布局表格单元格视图非常容易，真的。</p><p>我认为优化的手动布局代码总是比约束求解器更快，这给了我们平滑滚动的优势，这是一个本来很好的应用程序可能会脱颖而出的地方之一。</p><p>并且：因为布局代码不需要视图(只需要一个文章对象和一个宽度)，所以我们可以随时运行它。我们使用相同的代码来确定行的高度，而不必运行自动布局过程。</p><p>文本测量很慢-慢到连手动布局都太慢了。在NetNewsWire中，我们在缓存文本测量方面做了一些聪明的事情。</p><p>例如：如果我们知道一个给定的字符串在可用宽度为100时是20pt高，当可用宽度是200时，我们可以在不测量的情况下断定，当可用宽度是150时，它将是20pt高。</p><p>没有什么灵丹妙药。让一款应用程序变得快速意味着要做一系列不同的事情-这意味着要持续关注性能。🍕</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://inessential.com/2020/05/18/why_netnewswire_is_fast">https://inessential.com/2020/05/18/why_netnewswire_is_fast</a></div><div class="story_tags page_narrow"></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>