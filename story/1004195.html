<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>现代基于规则的模型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">现代基于规则的模型</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-29 11:53:28</div><div class="page_narrow text-break page_content"><p>机器学习模型有多种形状和大小。虽然深度学习模型目前的覆盖率最高，但还有许多其他类别的模型可以有效地跨越许多不同的问题领域。这篇文章简要总结了几个与基于树的模型密切相关的基于规则的模型(但不太广为人知)。</p><p>虽然这篇文章的重点是解释这些模型是如何工作的，但它与Rules包的发布不谋而合，Rules包是一个为这些模型提供用户界面的tidyModels包。tidyverse博客上的一个配套帖子描述了该软件包的用法。</p><p>机器学习中的规则已经存在了很长一段时间(Quinlan，1979)。本文的重点是将规则用于传统的有监督学习(与关联规则挖掘相对)。在功能工程上下文中，规则是条件逻辑语句。它也可以附加到某种预测值，例如。</p><p>从数据创建规则有多种方法。最流行的方法是创建一个基于树的模型，然后将模型结构“扁平化”为一组规则。这被称为“分而治之”的方法。</p><p>为了说明这一点，让我们使用来自加利福尼亚州萨克拉门托的房价数据集。删除了具有大量级别的两个预测器，以使规则输出更具可读性：</p><p>for(pkg in c(&#39；dplyr&#39；，&#39；model data&39；，&#39；rpart&39；)){if(！requiedNamespace(Pkg)){install.Packages(Pkg)}}库(Dplyr)数据(Sacramento，Package=#34；model data&34；)Sacramento&lt；-Sacramento%&&gt;%Mariate(Price。</p><p>##Tibble[932×7](S3：tbl_df/tbl/data.frame)##$bed：int[1：932]2 3 2 2 2 3 3 3 2 3.##$baths：num[1：932]1 1 1 2 1 2 2.##$sqft：int[1：932]836 1167 796 852 797 1122 1104 1177 941 1146.##$type：factor w/3 level&(##$sqft：int[1：932]836 1167 796 852 797 1122 1104 1177 941 1146)##$type：factor w/3 level&。，..：3 3 3 1 3 3 1.##$价格：Num[1：932]4.77 4.83 4.84 4.84 4.91.##$纬度：Num[1：932]38.6 38.5 38.6 38.5.##$经度：Num[1：932]-121-121-121-121.。</p><p>##n=932#节点)，拆分，n，偏差，yval##*表示终端节点#1)根932 48.5000 5.334##2)sqft&lt；1594535 18.7200 5.211##4)sqft&lt；1170235 8.0440 5.107##8)sqft&lt；934.5 71 2.2760 5.002*##9)sqft&gt；=1170164 4.6500 5.152*#5)sqft&gt；=121.3 300 6.1390 5.292##10)经度&lt；-121.3 243 4.8850 5.270*##11)经度&gt；=-121.3 57 0.6081 5.388*##3)sqft&gt；=1594397 10.6000 5.501##6)sqft&lt；2317245 4.7420 5.432##12)经度&lt；-121.3 205 3.3190 5.407*##13)经度&gt；=-121.3 40 0.6179 5.562*#7)sqft&gt；=2317152 2.8450 5.611#14)经度&lt；-121.2 110 1.6790 5.570*#15)经度&gt；=-121.2 42 0.4864 5.720*</p><p>此特定树中的拆分涉及相同的两个预测器。这些到终端节点的路径由一组IF-THEN规则组成。考虑到第八个终端节点的路径：</p><p>如果(sqft&lt；1594amp；sqft&lt；1169.5&amp；sqft&lt；934.5)，则PRED=5.001820。</p><p>很容易将这条规则删减到只有934.5平方英尺。总而言之，从此模型生成的规则将是：</p><p>##价格##5.0当sqft；935##5.2当sqft是935到1170##5.3当sqft是1170到1594&amp；经度&gt；-121##5.4当sqft是1170到1594&amp；经度&gt；=-121##5.4当sqft是1594到2317&amp；经度&lt；-121##5.6当sqft是1594到2317&amp；经度&gt；=-。-121##5.7，当sqft&&gt;=2317&amp；经度&&gt;=-121时。</p><p>哪些更现代的模型可以使用或生成规则？我们将介绍三个(它们都包含在规则包中)。</p><p>C4.5算法(Quinlan，1993b)是一个早期的基于树的模型，它是在更著名的Cart模型之后不久发布的。此模型的一个很酷的方面是，它可以生成分类树或一组规则。这些规则是从原始树派生的，其方式与上面为rpart显示的方式大致相同。</p><p>多年来，作者(Ross Quinlan)不断进化出称为C5.0的下一代模型。大约10年前，他开源了这个型号，于是C50R包诞生了。与其前身一样，C5.0可以用于树或规则。这个模型有很多进步(在Kuhn and Johnson(2013)中有详细介绍)，但最重要的是包含了Boosting。实际上，您可以创建分类规则集合。它更类似于经典的AdaBoost方法，而不是通过更现代的随机梯度提升范式来解决问题。</p><p>由于c5.0仅用于分类，因此虹膜数据的单个规则集示例如下：</p><p>规则1：(50，提升2.9)花瓣长度=1.9-&gt;类别setosa[0.981]规则2：(48/1，提升2.9)花瓣长度=4.9花瓣宽度=1.7-&gt;花色级[0.960]规则3：(46/1，提升2.9)花瓣宽度。Virginica类[0.958]规则4：(46/2，Lift2.8)花瓣长度；4.9-&gt；类Virginica[0.938]默认类：setosa。</p><p>如果在虹膜数据上使用，具有50个组成模型的助推组合总共使用了276个规则，并且每次迭代平均每个规则集有5.52个规则。</p><p>控制每个规则集复杂性的主要方法是调整在节点内进行附加拆分所需的最小数据点数量。此参数的默认值为两个数据点。如果将该值增加到20，则规则的平均数量从5.52个规则减少到3.2个规则。</p><p>调优时，另一个主要调优参数是提升迭代的次数。C50R包支持跨Boosting迭代的子模型预测；在许多值上调优此参数的计算成本不是很高。</p><p>前面提到的罗斯·昆兰(Ross Quinlan)也开发了模型树(Quinlan，1992)。这些是基于回归树的模型，在终端节点中包含线性回归模型。这个模型被称为M5，与C5.0非常相似，有一个基于规则的模拟。大多数基于树的模型，特别是树的集合，倾向于产生不适合尾部的模型(很像回归到平均值)。模型树不会受到这个问题的影响，因为它们的终端回归模型可以在整个结果数据范围内做出预测。</p><p>在20世纪90年代最初的一系列论文之后，昆兰没有发表太多关于方法论的文章，因为他发展了这种方法论。现代版的示范规则被称为立体主义。立体主义规则和M5规则(在Kuhn和Johnson(2013)中列举)之间有一些小的技术差异，但主要的改进是：</p><p>委员会合奏类似于助推器。在Boosting中，会按顺序创建一组模型。对于当前的Boosting迭代，使用由以前模型的结果定义的案例权重创建模型。在委员会中，案例权重不变。取而代之的是，针对委员会的每次迭代修改结果值。例如，如果样本之前预测不足，则其结果值会被更改为更大，这样模型就会向上拉，以努力停止预测不足。</p><p>在委员会中，第一个模型使用原始结果值\(y\)。在进一步迭代中，将使用修改后的值\(y^*\)。对于迭代\(m\)，模型使用此调整公式：</p><p>作为演示，下面的图表显示了伪结果如何在迭代中变化。这所房子的观测价是5.3英镑。在第一次迭代中，模型预测不足(显示为实心黑点)。垂直线表示此模型的残差。在下一次迭代中，开放的蓝色圆圈显示\(y^*{(2)}\)的值。在第二次迭代中，对该数据点的预测变得更差，但随着迭代的进行，残差通常会变小。</p><p>总体预测是通过对委员会模型预测进行平均来做出的。这在Cubist做出的基于模型的预测中得出了结论。</p><p>在模型预测之后，可以选择进行模型后最近邻调整(Quinlan，1993a)。当预测新的数据点时，在训练集中找到K最近的邻居(连同它们的原始预测)。如果邻居的训练集预测表示为\(t\)，则调整为：</p><p>其中权重\(w_\ell\)基于反向距离(以便远点对平差的贡献较小)。当原始预测和新预测之间的差异较大时，调整幅度较大。随着新样本的预测与其最接近的相邻样本之间的差异增大，调整变得更大。</p><p>假设我们的模型只使用平方英尺和经度作为预测值。训练数据如下所示，新的预测点表示为一个大的红色正方形。训练集中最近的6个邻居显示为红色圆圈。圆的大小表示重量的大小。这表明近点比远点对平差的影响更大。</p><p>此调整通常会提高模型的性能。有趣的是，在调优时通常会出现这样一种模式，即1近邻模型比不使用调整要差得多，但两个或更多个邻居的工作要好得多。一种想法是，单个邻居的使用可能过度适合训练集(就像在更传统的K-NN模型中会发生的那样)。</p><p>使用这两种技术，立体主义往往会在性能方面产生非常有竞争力的效果。两个主要参数是委员会成员的数量和在调整中使用的最近邻居的数量。Cubist软件包可以使用相同的拟合模型来预测邻居的数量，因此在调整此参数时几乎不需要计算成本。</p><p>对于萨克拉门托的数据，单个模型(例如一个委员会)由6条规则组成，每条规则都有自己的线性回归模型。例如，前四条规则是：</p><p>##规则1：[198例，平均值5.187264，范围4.681241到5.759668，估计误差0.131632]#如果##sqft&lt；=1712时##纬度&&gt;38.46639#纬度&lt；=38.61377##经度&&gt;；-121.5035##THEN##结果=-48.838393+0.000376平方英尺+1.39纬度#规则2：[121.5035例，平均值5.220439，范围4.477121到5.923762，最大错误0.105572]#如果##平方英尺=1712##纬度；38.61377#经度&&gt;-38.61377##经度&lt；=-121.0504##THEN##结果=93.155414+0.000431平方英尺+0.78经度+0.16纬度#规则3：[90箱，平均值5.273133，范围4.851258至5.580444，最大误差0.078920]#如果##平方英尺=1712##纬度#。=38.46639##然后##结果=15.750124+0.000344平方英尺+0.09经度-0.005张床位##+0.005个浴缸#规则4：[35箱，平均值5.340909，范围5.018076到5.616476，最大错误0.086056]#如果##平方英尺=1712#经度=-121.5035#那么#结果=4.865655+0.000357平方英尺。</p><p>被预测的新样本将落入一个或多个规则条件，并且最终预测是所有相应线性模型预测的平均值。</p><p>如果该模型针对50个委员会运行，则在所有委员会中总共使用了271条规则，平均每位委员会成员使用了5.42条规则。</p><p>RuleFit模型(Friedman和Popescu，2008)在概念上相当简单：使用树集成创建一大组规则，将规则用作二元预测器，然后拟合只包括最重要规则特征的正则化模型。</p><p>例如，如果使用增强树来生成规则，则通过每棵树的每条路径都将生成可用于定义模型预测器的条件语句(如上面针对rpart所示)。如果对Sacramento数据使用具有100次Boosting迭代、限制为3个拆分的xgBoost模型，则会生成609条规则的初始集合。一些例子：</p><p>显然，规则显示了一些冗余；规则中往往有大量的相似之处。</p><p>这些预测器被添加到正则化回归模型(例如，线性或逻辑回归模型)，该模型将进行特征选择以删除无用或冗余的规则。根据模型受到的惩罚程度，用户可以选择最终模型中包含的规则数量。例如，根据惩罚的不同，萨克拉门托数据的最终规则集可以大到数百条，也可以小到几条。</p><p>我们可以生成glmnet变量重要性分数，然后根据原始预测器(而不是规则)参数化重要性。例如：对于惩罚值\(\λ\)=0.005：</p><p>RuleFit有许多调优参数；它继承了Boosting模型和glmnet(套索正则化量)的参数。幸运的是，可以使用相同的模型对象在套索惩罚中进行多个预测。</p><p>总而言之，RuleFit是一种将规则用作功能的简洁而强大的方法。将此模型与立体主义进行对比是很有趣的：</p><p>Ross Quinlan一直支持我们发布C5.0和Cubist内部工作原理的努力。我要感谢他的帮助和他多年来所做的一切出色的工作。</p><p>Popescu Be(2008)&lt;通过规则集合的预测性学习&gt;，“应用统计年鉴”，第916-954页。</p><p>Quinlan R(1979)。“通过归纳从大量的例子中发现规则。”微电子时代的专家系统。</p><p>Quinlan R(1992)。“在连续的课堂上学习。”第五届澳大利亚人工智能联席会议论文集，第343-348页。</p><p>Quinlan R(1993a)。“将基于实例的学习和基于模型的学习相结合。”第十届国际机器学习会议论文集，第236-243页。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rviews.rstudio.com/2020/05/21/modern-rule-based-models/">https://rviews.rstudio.com/2020/05/21/modern-rule-based-models/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/规则/">#规则</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rule/">#rule</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模型/">#模型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>