<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>这就是匹克你好世界的样子</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">这就是匹克你好世界的样子</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-17 16:47:43</div><div class="page_narrow text-break page_content"><p>每个人以前都做过“你好世界”节目。但现在我已经有了几年的语言使用经验，我开始提出一个最紧迫的问题--我们如何让C语言的Hello World变得尽可能错综复杂和难以理解？这篇帖子记录了我试图做到这一点的睡眠不足的最终结果。</p><p>我很快意识到，我必须首先设置一些基本规则，以便对“无用”的代码行有一个合理的限制：</p><p>因为我们使用的是纯C语言，所以不会有类(所以没有HelloWorldFactoryFactoryFactorySingletons)。</p><p>所有的#include指令都应该是程序所必需的(因此不会链接十亿个.h文件)。</p><p>每个函数必须对程序做一些基本的事情(所以没有函数只调用另一个或无用的#定义)。</p><p>该程序不接受任何输入，并编写Hello World！精确到终点站(这样就不会进行其他计算)。</p><p>这样，我们就开始使用malloc在单独的函数中构建字符串：</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；char*Generate_Words(){char*ret=malloc(13)；ret[0]=&#39；H&#39；；ret[1]=&#39；e&#39；；ret[2]=&#39；l&#39；；ret[3]=&#39；l&#39；；ret[4]=&#39。o&#39；；ret[5]=&#39；ret[6]=&#39；W&#39；；ret[7]=&#39；o&#39；ret[8]=&#39；r&#39；；ret[9]=&#39；l&#39；；ret[10]=&#39；d&#39；；ret[11]=&#39；！&#39；；ret[12]=&#39；\0&#39；；//不能忘记我们的空运算符！return ret；}int main(){char*ret=Generate_word()；printf(Ret)；free(Ret)；return 0；}</p><p>这已经比以前复杂多了，但我们可以把它弄得更糟！将字母的直接赋值替换为按位运算，我们就会得到这样的怪异效果：</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；char*Generate_Words(){char*ret=malloc(12)；char c=0x01；ret[0]=(c&lt；&lt；6)|(c&lt；&lt；3)；//H is 0x48 ret[1]=c|(c&lt；&lt；2)|(c。5)|(c&lt；&lt；6)；//&#39；e&#39；is 101 ret[2]=((c|(c&lt；&lt；1))&lt；&lt；2)|(c|(c&lt；&lt；1))&lt；&lt；5)；//&#39；l&#39；is 108 ret[3]=(c|(c&lt；&lt；1))&lt；&lt；2)|(c|(c&lt；&lt；1))&lt；&lt；5)；//&#39；l&#39；is 108 ret[4]=(c|(c&lt；&lt；1))|((c|(c&lt；&lt；1)&lt；&lt；2)|((c|(c&lt；&lt；1))&lt；&lt；5)；//&#39；o&#39；is 111 ret[5]=(c&lt；&lt；5)；//&#39；&#39；is 32 ret[6]=c|(c&lt；&lt；2)|(c&lt；&lt；1)|(c&lt；&lt；1)&lt；&lt；3|(c&lt；&lt；1)&lt；&lt；5；//&#39；W&#39；is 87 ret[7]=(c|(c&lt；&lt；1))|((c|(c&lt；&lt；1))&lt；&lt；2)|(c|(c&lt；&lt；1))&lt；&lt；5)；//&#39；o&#39；is 111 ret[8]=(c&lt；&lt；1)|((c&lt；&lt；2)|c)&lt；&lt；4；//&#39；r&#39；is 114 ret[9]=((c|(c&lt；&lt；1))&lt；&lt；2)|((c|(c&lt；&lt；1)&lt；&lt；5)；//&#39；l&#39；is 108 ret[10]=(c&lt；&lt；2)|(c&lt；&lt；5)|(c&lt；&lt；6)；//&#39；d&#39；is 100 ret[11]=(c&lt；&lt；5)|c；//&#39；！&#39；is 33 return ret；}int main(){char*ret=Generate_word()；printf(Ret)；free(Ret)；return 0；}。</p><p>如您所见，出于可读性的考虑，我添加了注释和一些额外的括号。但是，如果我们删除c变量以节省空间，并且只依赖于先前在ret中定义的值进行计算，结果会怎样呢？</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；string.h&gt；#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；string.h&gt；#include&lt；unistd.h&gt；volatile u_int8_t a=0-1；volatile u_int8。z=ALIGNED_ALLOC(sysconf(_SC_LEVE1_DCACHE_LINESIZE)，1*10+3)：a！=1*10+3？Z[a]=a==0？z[a]=(1&lt；&lt；(a+6))|(1&lt；&lt；(a+3))：a==1？(Z[a-1]&amp；(1&lt；&lt；(a+5))|(z[a-1]&gt；&gt；a)|(z[a-1]&gt；&gt；(A+5))：A==2？z[a-2]|z[1]&amp；~(z[a-2]&gt；&gt；(a+4)：a==4？z[a-2]|z[a-3]|(z[a-4]&gt；&gt；(a+1))：a==5？(z[a-4]&amp；z[a-3]&amp；z[a-5]&gt；&gt；(a-4)：a==6？(Z[a-2]&amp；~z[a-1]|(z[a-6]&gt；&gt；(a-4))&amp；~(z[a-6]&gt；&gt；(a-2)&lt；&lt；(a-5)：a==8？(~z[a-7]&amp；z[a-2])|z[a-3]|z[a-3]&lt；&lt；(a-7)：a==10？z[a-9]&amp；~(z[a-5]&gt；&gt；(a-5))：a==11？z[a-6]|(z[a-1]&amp；z[a-3])&gt；&gt；(a-5))：a-a：0；if(a==1*10+3){memcpy(z+3，z+2，1)；memcpy(z+9，z+3，1)；memcpy(z+7，z+4，1)；printf(&#34；%s&#34；，z)；free(Z)；return 0；}a=a+1；main()；}u_int8_t*Generate_Words(){u_int8_t*ret=malloc(13)；ret[0]=(1&lt；&lt；6)|(1&lt；&lt；3)；ret[1]=(ret[0]&amp；(1&lt；&lt；6))|(ret[0]&gt；&gt；1)|(ret[0]&gt；&gt；6)；ret[2]=ret[0]|ret[1]&amp；~(ret[0]&gt；&gt；6)；ret[4]=ret[2]|ret[1]|(ret[0]&gt；&gt；5)；ret[5]=(ret[1]&amp；ret[2]&amp；ret[0])&gt；&gt；1；ret[6]=(ret[4]&amp；~ret[5]|(ret[0]&gt；&gt；2))&amp；~(ret[0]&gt；&gt；4&lt；&lt；1)；ret[8]=(~ret[1]&amp；ret[6])|ret[5]|ret[5]&lt；&lt；1；ret[10]=ret[1]&amp；~(ret[5]&gt；&gt；5)；ret[11]=ret[5]|((ret[10]&amp；ret[8])&gt；&gt；6)；ret[12]=0；memcpy(ret+3，ret+2，1)；memcpy(ret+9，ret+3，1)；memcpy(ret+7，ret+4，1)；ret[12]=0；return ret；}int main(){u_int8_t*ret=Generate_Words()；printf(&#34；%s&#34；，ret)；free(Ret)；return 0；}。</p><p>现在，我们的代码开始看起来很好(不好？)。唯一的问题是它运行的时间太长了--我两年前的超级强大的笔记本电脑处理器几乎花了我两年的时间</p><p>等等，我们添加的for循环可以用更复杂的方式编写！让我们这样做：</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；string.h&gt；#include&lt；unistd.h&gt；Volatile unsign int a=0-1；volatile u_int8_t*z=null；int main(){switch(A){case 0-1：z=aligned_alloc(sysconf(_SC_level 1_DCACHE_LINC。案例1*10+3：memcpy(z+3，z+2，1)；memcpy(z+9，z+3，1)；memcpy(z+7，z+4，1)；printf(&#34；%s&#34；，z)；free(Z)；返回0；默认值：z[a]=a==0？z[a]=(1&lt；&lt；(a+6))|(1&lt；&lt；(a+3))：a==1？(Z[a-1]&amp；(1&lt；&lt；(a+5))|(z[a-1]&gt；&gt；a)|(z[a-1]&gt；&gt；(A+5))：A==2？z[a-2]|z[1]&amp；~(z[a-2]&gt；&gt；(a+4)：a==4？z[a-2]|z[a-3]|(z[a-4]&gt；&gt；(a+1))：a==5？(z[a-4]&amp；z[a-3]&amp；z[a-5]&gt；&gt；(a-4)：a==6？(Z[a-2]&amp；~z[a-1]|(z[a-6]&gt；&gt；(a-4))&amp；~(z[a-6]&gt；&gt；(a-2)&lt；&lt；(a-5)：a==8？(~z[a-7]&amp；z[a-2])|z[a-3]|z[a-3]&lt；&lt；(a-7)：a==10？z[a-9]&amp；~(z[a-5]&gt；&gt；(a-5))：a==11？z[a-6]|((z[a-1]&amp；z[a-3])&gt；&gt；(a-5)：a-a；}a=a+1；main()；}。</p><p>嗯，我们在那里的交换机占用了相当大的空间，不是吗？让我们解决这个问题，并稍微清理一下代码：</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；string.h&gt；#include&lt；unistd.h&gt；volatile u_int8_ta a=0-1；volatile u_int8_t*z=null；int main(){a=0-1？z=ALIGNED_ALLOC(sysconf(_SC_LEVE1_DCACHE_LINESIZE)，1*10+3)：a！=1*10+3？Z[a]=a==0？z[a]=(1&lt；&lt；(a+6))|(1&lt；&lt；(a+3))：a==1？(Z[a-1]&amp；(1&lt；&lt；(a+5))|(z[a-1]&gt；&gt；a)|(z[a-1]&gt；&gt；(a+5))：a==2？z[a-2]|z[1]&amp；~(z[a-2]&gt；&gt；(a+4)：a==4？z[a-2]|z[a-3]|(z[a-4]&gt；&gt；(a+1))：a==5？(z[a-4]&amp；z[a-3]&amp；z[a-5]&gt；&gt；(a-4)：a==6？(z[a-2]&amp；~z[a-1]|(z[a-6]&gt；&gt；&gt；(a-4))&amp；~(z[a-6]&gt；&gt；(a-2)&lt；&lt；(a-5)：a==8？(~z[a-7]&amp；z[a-2])|z[a-3]|z[a-3]&lt；&lt；(a-7)：a==10？z[a-9]&amp；~(z[a-5]&gt；&gt；(a-5))：a==11？z[a-6]|(z[a-1]&amp；z[a-3])&gt；&gt；(a-5))：a-a：0；if(a==1*10+3){memcpy(z+3，z+2，1)；memcpy(z+9，z+3，1)；memcpy(z+7，z+4，1)；printf(&#34；%s&#34；，z)。Main()；}。</p><p>现在开始了--一个仅用一行逻辑打印Hello World的程序！</p><p>我相信有更多的方法可以改善这个项目的不可读性，所以如果你看到可以改进的地方，请让我知道！</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://h313.info/blog/cpp/2020/05/17/this-is-what-peak-hello-world-looks-like.html">https://h313.info/blog/cpp/2020/05/17/this-is-what-peak-hello-world-looks-like.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/你好/">#你好</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/peak/">#peak</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ret/">#ret</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>