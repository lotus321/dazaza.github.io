<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Zig提供裸机上内核死机的堆栈跟踪</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Zig提供裸机上内核死机的堆栈跟踪</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-28 06:19:58</div><div class="page_narrow text-break page_content"><p>上周，我作为一名程序员的职业生涯达到了一个令人兴奋的里程碑。这是我有生以来第一次直接在硬件上运行代码，裸机和我的代码之间没有操作系统。</p><p>在某些情况下，这个副项目的目标是创建一个2-4人的街机游戏，直接在树莓派3+上运行。</p><p>在刚刚运行Hello World之后，该软件在启动时不仅可以通过串行UART发送消息：</p><p>嗯，在编写所有这些代码时，我不可避免地会遇到错误和崩溃。当这种情况发生时，我想迅速了解这是什么意思。通常，在Zig中，当出现问题时，您会得到一个很好的堆栈跟踪，如下所示：</p><p>然而，这个示例针对的是Linux，而这个街机游戏项目是独立的。独立式中的等效代码实际上只是挂起了CPU：</p><p>-a/src/main.zig+b/src/main.zig seral.log(&#34；Hello World！ClashOS 0.0\n&#34；)；+var x：u8=255；+x+=1；+seral.log(&#34；get here\n&#34；)；</p><p>运行时，您将看到我们从未收到收到的消息，但我们也不会打印任何类型的错误消息或任何内容。</p><p>要理解这一点，我们可以查看默认的死机处理程序。在Zig中，您可以在根源文件中提供pub Fn死机。但如果您不提供此功能，则使用默认值：</p><p>Pub FN死机(msg：[]const U8，error_return_trace：？*builtin.StackTrace)noreturn{@setLD(True)；switch(builtin.os){builtin.Os.freestanding=&gt；{while(True){}}，Else=&gt；{const first_trace_addr=@ptrToInt(@rereturn Address())；std.debug.panicExtra(Error_Return_){}，{const first_trace_addr=@ptrToInt(@rereturn Address())；std.debug.panicExtra(error_return_。</p><p>在这里，我们可以看到为什么前面的代码挂起-独立目标的默认死机处理程序是简单的while(True){}。</p><p>pub FN死机(message：[]const U8，STACK_TRACE：？*builtin.StackTrace)noreturn{seral.write(&#34；\n！内核死机！\n&#34；)；seral.write(Message)；seral.write(&#34；\n&#34；)；While(True){}}。</p><p>这已经好多了。我们可以看到整数溢出导致了内核死机，但是在任何地方都可能发生整数溢出。打印完整的堆叠轨迹不是很好吗？</p><p>是的，是的，会的。要做到这一点，我需要做的第一件事就是从内核内部访问DWARF调试信息。但是我甚至没有文件系统。这怎么行得通呢？</p><p>放轻松！只需将矮人信息直接放入内核的内存中即可。我修改了我的链接器脚本来实现这一点：</p><p>.rodata：ALIGN(4K){*(.rodata)__DEBUG_INFO_START=.；KEEP(*(.debug_info))__DEBUG_INFO_END=.；__DEBUG_ABBRV_START=.；KEEP(*(.debug_abbrev))__DEBUG_ABBRV_END=.；__DEBUG_STR_STR=.；KEEP(*(.debug_str))__DEBUG_STR_。Keep(*(.debug_line))__debug_line_end=.；__debug_range_start=.；Keep(*(.debug_range))__debug_range_end=.；}。</p><p>lld：错误：.rodata&gt；&gt；&gt；/home/andy/dev/clashos/zig-cache/clashos.o：(.debug_info)：0x0&gt；&gt；&gt；输出节的节标志不兼容.rodata：0x12lld：错误：.rodata&gt；&gt；&gt；内部&gt；：(.debug_str)：0x30&gt；&gt；&gt；输出节.rodata：0x12lld：错误。/home/andy/dev/clashos/zig-cache/clashos.o：(.debug_line)：0x0&gt；&gt；&gt；输出节.rodata：0x32</p><p>在对一份错误报告进行了反复讨论后，乔治·里马尔(George Rimar)建议干脆删除那项特定的检查，因为这可能是一种过于严格的执行。我在我的LLD叉子里试过了，它起作用了！调试信息现在已链接到我的内核映像中。在完成了这篇博客文章中的其余步骤后，我向上游提交了一个补丁，Rui已经将其合并到了LLD中。这将与LLVM8一起发布，同时Zig的LLD fork也有补丁。</p><p>在这一点上，编写我的内核和Zig标准库的堆栈跟踪工具之间的粘合代码是一件简单的事情。在Zig中，您不必刻意支持独立模式。不依赖于特定操作系统的代码将在独立模式下工作，这要归功于Zig的懒惰的顶层声明分析。由于标准库堆栈跟踪代码不调用任何操作系统API，因此它支持独立模式。</p><p>用于从ELF文件打开调试信息的Zig STD lib API如下所示：</p><p>但是这个内核非常简单，它甚至不在ELF文件中。它直接从二进制文件启动。我们只是将调试信息部分直接映射到内存中。为此，我们可以使用较低级别的API：/Initialize DWARF INFO。调用者有责任在调用之前初始化大多数/DwarfInfo字段。这些字段可以保持未定义状态：/*abbrev_table_list/*Compile_unit_listpub FN openDwarfDebugInfo(di：*DwarfInfo，allocator：*mem.Allocator)！void。</p><p>发布常量DwarfInfo=struct{DWARF_SEEKABLE_STREAM：*DwarfSeekableStream，dwarf_in_stream：*DwarfInStream，endian：builtin.endian，debug_info：Section，debug_abbrev：Section，debug_str：Section，debug_line：Section，debug_range：？Section，abbrev_table_list：ArrayList(缩写vTableHeader。</p><p>要将这些连接起来，粘合代码需要将带有偏移量的DwarfInfo字段初始化为std.io.SeekableStream，它可以实现为指向内存的简单指针。通过声明外部变量，然后查看它们的地址，我们可以找出链接器脚本中定义的符号在内存中的位置。</p><p>对于.debug_abbrev、.debug_str和.debug_range，我不得不将偏移量设置为0以解决LLD问题，认为出于某种原因这些部分从0开始。</p><p>var KERNEL_PARGIC_ALLOCATOR_BYTES：[100x1024]U8=未定义；VAR KERNEL_PARGIC_ALLOCATOR_STATE=std.heap.FixedBufferAllocator.init(kernel_panic_allocator_bytes[0..])；const内核_PARGIC_ALLOCATOR=&amp；kernel_panic_allocator_state.allocator；extern VAR__DEBUG_INFO_START：U8；外部VAR__DEBUG_INFO_END：U8；外部VAR_DEBUG_ABBRV_START：U8；外部VAR__DEBUG_ABBRV_END：U8；外部VAR__DEBUG_ABBRV_START：U8；外部VAR__DEBUG。extern var__debug_str_end：u8；extern var__debug_line_start：u8；extern var__debug_line_end：u8；extern var__debug_range_start：u8；extern var__debug_range_end：u8；fn dwarfSectionFromSymbolAbs(start：*u8，end：*u8)std.debug.DwarfInfo.Section{。}fn dwarfSectionFromSymbol(start：*u8，end：*u8)std.debug.DwarfInfo.Section{return std.debug.DwarfInfo.Section{.offset=@ptrToInt(Start)，.size=@ptrToInt(End)-@ptrToInt(Start)，}；}fn getSelfDebugInfo()！*std.debug.DwarfInfo{const S=。var in_stream_pos：usize=0；const in_stream=&amp；in_stream_state；fn readFn(self：*std.io.InStream(Anyerror)，buffer：[]U8)anyerror！usize{const ptr=@intToPtr([*]const U8，in_stream_pos)；@memcpy(Buffer.ptr，ptr，Buffer.len)；in_stream_pos+=。var SEEKABLE_STREAM_STATE=SEEKABLE_STREAM=SEEKABLE_STREAM_STATE；.earkForwardFn=SEEKFForwardFn，.getPosFn=getPosFn，.getEndPosFn=getEndPosFn，}；常量SEEKABLE_STREAM=&amp；SEEKABLE_STREAM_STATE；Fn SEEKTOFn(SELF：*SeekableStream，Pos：u。}fn getPosFn(self：*SeekableStream)anyerror！usize{return in_stream_pos；}fn getEndPosFn(self：*SeekableStream)anyerror！usize{return@ptrToInt(&amp；__debug_range_end)；}}；if(S.had_self_debug_info)return&amp；S.self_debug_info；S.Self_DEBUG_INFO=标准调试.DwarfInfo{.dwarf_SEEKABLE_STREAM=S.SEEKABLE_STREAM，.dwarf_in_STREAM=S.in_STREAM，.endian=builtin.Endian.Little，.debug_info=dwarfSectionFromSymbol(&amp；__debug_info_start，&amp；__DEBUG_INFO_END)，.debug_abbrev=dwarfSectionFromSymbolAbs(&amp；__debug_abbrev_start，&amp；__DEBUG_ABBRV_END)，.debug_str=dwarfSection。__DEBUG_STR_START，&amp；__DEBUG_STR_END)，.debug_line=dwarfSectionFromSymbol(&amp；__debug_line_start，</p><p>您可以看到，当需要分配时接受分配器作为参数的Zig常见实践对于内核开发非常方便。我们简单地静态分配一个100 KiB的缓冲区，并将其作为调试信息分配器进行传递。如果这个值变得太小，可以进行调整。</p><p>Pub FN死机(消息：[]const U8，STACK_TRACE：？*builtin.StackTrace)noreturn{序列.log(&#34；\n！内核死机！{}\n&#34；，message)；const wwarf_info=getSelfDebugInfo()catch|err|{Serial.log(&#34；Unable to get debug info：{}\n&#34；，@errorName(Err))；挂起()。var it=std.debug.StackIterator.init(first_trace_addr)；While(it.next())|Return_Address|{std.debug.printSourceAtAddressDwarf(DWARF_INFO，SERIAL_OUT_STREAM，RETURN_ADDRESS，TRUE，//tty color on printLineFromFile，)catch|err|{Serial.log(&#34；错过堆栈帧：{}\n&#34；，@errorName(Err))；Continue；}；}挂起()；}FN HANG()NORETURN{WHILE(True){}}FN printLineFromFile(out_stream：var，line_info：std.debug.LineInfo)anyerror！void{seral.log(&#34；TODO从文件打印行\n&#34；)；}。</p><p>你好，世界！ClashOS 0.0！内核死机！？中的整数overflow/home/andy/dev/clashos/src/main.zig:166:7：0x15e0。(Clashos)TODO打印文件^？：0x1c中的行？？(？)。</p><p>最后一行来自启动汇编代码，它没有源代码映射。但是通过观察内核的反汇编，我们可以看到它是正确的：</p><p>0000000000000000&lt；_Start&gt；：0：d53800a0 MRS x0，MPIDR_EL1 4：d2b82001 mov x1，#0xc1000000 8：8a210000 Bic x0，x0，x1 c：b4000040 CBZ x0，14&lt；Master&gt；10：14000003 b1c&lt；__Hang&gt；0000000000000014&lt；Master&gt；：14：b26503。</p><p>您可以看到，0x1c确实是对kernel_main的函数调用的返回地址(函数返回时将执行的下一条指令)。</p><p>你好，世界！ClashOS 0.0！内核死机！整数overflow/home/andy/dev/clashos/src/serial.zig:42:7：0x1b10 in？(Clashos)TODO打印文件^/home/andy/dev/clashos/src/main.zig：58：16：0x1110中的行？(Clashos)TODO打印文件^/home/andy/dev/clashos/src/main.zig：67：18：0xecc中的行？(Clashos)TODO打印文件^？：0x1c中的行？？(？)。</p><p>它看起来不错。但是我们能不能在上面加个樱桃，让它印上香肠呢？</p><p>同样，我们没有文件系统。printLineFromFile函数如何访问源文件？</p><p>有时最简单的解决方案就是最好的解决方案。如果内核在内存中只有它自己的源代码呢？</p><p>const source_files=[][]const U8{&#34；src/debug.zig&#34；，&#34；src/main.zig&#34；，&#34；src/mmio.zig&#34；，&#34；src/seral.zig&#34；，}；fn printLineFromFile(out_stream：var，line_info：std.debug.LineInfo)anyerror！void{inline for(Source_Files)|src_path|{if(std.mem.endsWith(u8，line_info.file_name，src_path)){const Contents=@EmbedFile(&#34；../&#34；++src_path)；尝试printLineFromBuffer(。(源文件{}未添加到std/debug.zig中)\n&#34；，line_info.file_name)；}。</p><p>在这里，我们利用了inline Form和@EmbedFile，并且可以打印我们自己的源文件中的代码行。将printLineFromBuffer作为练习留给读者。</p><p>你好，世界！ClashOS 0.0！内核死机！整数overflow/home/andy/dev/clashos/src/serial.zig:42:7：0x1b10 in？(Clashos)x+=1；^/home/andy/dev/clashos/src/main.zig：58：16：0x1110 in？(Clashos)seral.om()；^/home/andy/dev/clashos/src/main.zig：67：18：0xecc in？(Clashos)SOME_Function()；^？：？：：0x1c中？？(？)。</p><p>现在，Zig提供的所有针对未定义行为的保护都会产生这样的结果。</p><p>我使用Zig的一个大目标是改进嵌入式和操作系统的开发过程。我希望你和我一样对这里的潜力感到兴奋。</p><p>如果这篇博客文章抓住了你的兴趣，也许你会想看看这个Hello World x86内核，它附带了一段我实时编码的视频。多亏了一条富有洞察力的Twitch评论，它只支持Zig代码，不需要汇编。</p><p>Zig编程语言是众筹的，不受制于任何企业或一组企业。请考虑赞助我的工作。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html">https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/provide/">#provide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内核/">#内核</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>