<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SSL终止交换机在iOS 12上的工作原理</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SSL终止交换机在iOS 12上的工作原理</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-26 10:36:42</div><div class="page_narrow text-break page_content"><p>两周前，我发布了新版本的SSL Kill Switch，这是我的黑盒工具，用于禁用iOS应用程序中的SSL锁定，以增加对iOS 12的支持。</p><p>iOS11和iOS12之间的网络堆栈发生了重大变化，难怪iOS11版本的SSL Kill Switch不能在(越狱)iOS12设备上工作。这篇文章描述了为了支持iOS12，我必须对该工具所做的更改。</p><p>在移动应用程序中实现SSL固定需要在应用程序打开与此服务器的SSL连接时，自定义应用程序在服务器证书链上执行的验证逻辑。定制SSL验证几乎总是通过某种回调机制完成的，在回调机制中，应用程序代码在连接的初始TLS握手期间接收服务器的证书链，然后必须对该链做出决定(它是否“有效”)。例如，在iOS上：</p><p>用于打开HTTPS连接的最高级别接口是NSURLSession，它通过[NSURLSessionDelegateHTTPS委托方法]实现验证回调。</p><p>当使用低级Network.framework(IOS 12中新提供)时，可以使用sec_protocol_options_set_verify_block()将块设置为验证回调。</p><p>这篇来自Apple文档的旧文章介绍了如何使用其他iOS网络API自定义验证：HTTPS服务器信任评估。</p><p>因此，在应用程序中禁用SSL固定的高级策略是防止触发SSL验证回调，以便永远不会执行负责实现固定的应用程序代码。</p><p>在iOS上，相对容易阻止调用NSURLSessionDelegate验证方法(SSL Kill Switch的早期版本就是这样工作的)，但是使用较低级别API(如Network.framework)的iOS应用程序怎么办？由于iOS上的每个网络API都构建在另一个之上，因此在最低级别禁用验证回调可能会禁用所有较高级别的网络API的验证，这将允许该工具针对更多应用程序工作。</p><p>从iOS 8开始，iOS上的网络堆栈总体上经历了很大的变化，而在iOS 12上，SSL/TLS堆栈构建在自定义的分支上(我想？)。BoringSSL的。例如，可以通过在运行打开连接的应用程序时在随机BoringSSL符号上设置断点来看到这一点：</p><p>如果您还记得这个策略：“防止SSL验证回调被触发”，很可能通过对准并修补iOS上最低级别的SSL/TLS API BoringSSL，iOS上所有更高级别的API(包括NSURLSession)也会关闭钉住验证。</p><p>使用BoringSSL时，自定义SSL验证的一种方法是通过SSL_CTX_SET_CUSTOM_VERIFY()函数配置验证回调函数：</p><p>//定义SSL/TLS握手过程中要触发的证书验证回调//定义在SSL/TLS handshakessl_ify_result_t ify_cert_chain_callback(ssl*ssl，uint8_t*out_alert){//检索服务器在握手时发送的证书链STACK_of(X509)*certificateChain=ssl_get_Peer_cert_chain(Ssl)；//如果do_CUSTOM_VALIDATION(certificateChai。}ELSE{//否则关闭连接返回SSL_VERIFY_INVALID；}}//对所有使用SSL_ctxSSL_CTX_SET_CUSTOM_VERIFY(SSL_CTX，SSL_VERIFY_PEER，VERIFY_CERT_CHAIN_CALLBACK)实现的未来SSL/TLS连接启用我的回调；</p><p>使用为NSURLSession启用SSL固定的测试应用程序，我能够确认在打开连接时确实会调用SSL_CTX_SET_CUSTOM_Verify()：</p><p>我们还可以看到APPLE/DEFAULT IOS验证回调函数作为第三个参数(在寄存器x2中)传递：boringssl_context_certificate_verify_callback().。该回调很可能包含(以及其他内容)逻辑，用于设置我的测试应用程序的NSURLSession回调/委托方法，以便最终使用服务器证书进行调用。</p><p>不出所料，我的测试应用程序用于固定验证代码的委托方法确实得到了执行：</p><p>我已经将我的测试应用程序设计为使其自定义/固定验证逻辑始终失败：</p><p>因此，如果我确实找到了绕过钉住的方法，则此连接应该会成功。</p><p>现在我们已经有了计划和正确的测试设置(带钉住的应用程序、越狱设备、Xcode等)，让我们开始工作吧！</p><p>我尝试的第一件事是用一个完全不检查服务器证书链的空回调替换由IOS网络堆栈boringssl_context_certificate_verify_callback()，设置的默认BoringSSL回调：</p><p>//我的不检查任何内容的邪恶回调ssl_Verify_Result_t Verify_Callback_That_Does_Not_Validation(void*ssl，uint8_t*out_alert){return SSL_Verify_OK；}//我的邪恶&34；SSL_CTX_SET_CUSTOM_VERIFY()静态无效REPLACE_SSL_CTX_SET_CUSTOM_VERIFY(void*ctx，int mode，SSL_VERIFY_RESULT_t(*CALLBACK)(void*SSL，uint8_t*out_alert))的替换函数{//始终忽略传递的回调，改为设置我的&#34；邪恶&#34；回调Original_SSL_CTX_SET_CUSTOM_VERIFY(CTX，SSL_VERIFY_NONE VERIFY_CALLBACK_That_。}//最后，使用MobileSubstrate将SSL_CTX_SET_CUSTOM_VERIFY()替换为MY&#34；EVISE&#34；REPLEED_SSL_CTX_SET_CUSTOM_VERIFY()void*boringssl_Handle=dlopen(&#34；/usr/lib/libboringssl.dylib&#34；，RTLD_NOW)；void*SSL_CTX_SET_CUSTOM_VERIFY=dlsym(boringssl_Handle。if(SSL_CTX_SET_CUSTOM_VERIFY){MSHookFunction((void*)SSL_CTX_SET_CUSTOM_VERIFY，(void*)REPLACE_SSL_CTX_SET_CUSTOM_VERIFY，NULL)；}。</p><p>在将其实现为MobileSubstrate调整并将其注入到我的测试应用程序中之后，发生了一些有趣的事情：我的测试应用程序的NSURLSession委托方法不再被调用(意味着它被“绕过”)，但是该应用程序完成的第一个连接将失败，并出现一个新的/未知错误“Peer is not Authenticated”，如日志中所示：</p><p>TrustKitDemo-Objc[3320：160146]=SSL终止开关2：replaced_SSL_CTX_set_custom_verifyTrustKitDemo-ObjC[3320:160146]无法克隆信任错误域=NSOSStatusErrorDomain Code=-50&#34；NULL信任输入&#34；用户信息={NSDescription=NULL信任输入}[-50]TrustKitDemo-Objc[3320：160146][BoringSSL]boringssl_SESSION_FINISH_HANSHARK(306)[c1.1：2][0x10。正在断开连接.TrustKitDemo-Objc[3320：160146]NSURLSession/NSURLConnection HTTP加载失败(kCFStreamErrorDomainSSL，-9810)TrustKitDemo-Objc[3320：160146]任务&lt；15E1F3B0-0B73-468A-9132-3E19048DDAE3&gt；.&lt；1&gt；已完成，错误代码：-1200.。</p><p>然后在应用程序本身中，第一个连接将失败，并出现与以前不同的错误：</p><p>但是，后续连接到同一服务器将会成功，而不会触发钉住验证回调：</p><p>因此，除了第一个连接之外，我对所有连接都绕过了钉住。快到了，…。</p><p>我需要更多的上下文来理解“Peer is not Authenticated”错误是什么，所以我最终从我的iOS12设备上拉出了共享缓存(苹果的所有库和框架都在这里，包括BoringSSL)，如本指南中所述。</p><p>在将libboringssl.dylib加载到Hopper中之后，我能够在一个名为boringssl_session_Finish_handshake()的函数中找到“Peer is not Authenticated”错误的字符串(在屏幕截图中标记为“1”)：</p><p>为了更好地理解错误本身，我试图理解该函数在做什么，但是由于我几乎不了解arm64(或任何)程序集，所以我无法理解它。我尝试了其他一些方法(例如修补boringssl_context_certificate_verify_callback()本身)，但没有找到任何有效的方法。</p><p>当我的周末时间不多了，我可以让自己花在这个上面的时候，我选择了一个更绝望的方法。如果您再次查看反编译的boringssl_session_finish_handshake()函数，您可以看到两个“主”代码路径，这两个路径有条件地由if/Else语句触发，“Peer WAS Not Authenticated”错误出现在“if”代码路径中，而不是“Else”路径中。</p><p>一种天真的尝试是阻止具有此错误的代码路径运行，即。“如果”路径。如截图所示，触发“if”分支的一个条件是(_SSL_GET_PSK_Identity()==0x0)(在截图中标记为“2”)。如果我们将此函数修补为不返回0，以强制执行“Else”代码路径(这不会触发“Peer was not Authenticated”错误)，会怎么样？</p><p>//使用MobileSubstrate将ssl_GET_PSK_IDENTITY()替换为该函数，该函数从不返回0：CHAR*REPLACE_SSL_GET_PSK_IDENTITY(VOID*ssl){Return&#34；notarealPSKidentity&#34；；}MSHookFunction((void*)SSL_GET_PSK_IDENTITY，(VOID*)REPLEED_SSL_GET_PSK_IDENTITY，(void**)NULL)；</p><p>在将这个运行时补丁注入我的测试应用程序后，它起作用了！甚至第一次连接都成功了，我的应用程序的验证回调从未被触发。我通过修补BoringSSL绕过了应用程序的SSL固定验证代码。</p><p>这显然不是一个非常干净的运行时补丁，虽然在应用它之后似乎一切正常(这令人惊讶)，但它会触发错误，每当应用程序打开连接时，都会在日志中看到这些错误：</p><p>TrustKitDemo-Objc[3417：166749]无法克隆信任错误域=NSOSStatusErrorDomain Code=-50&#34；空信任输入&#34；用户信息={NSDescription=空信任输入}[-50]。</p><p>它可能会弄乱与TLS-PSK密码套件相关的代码，也就是实际使用ssl_get_psk_entity()函数时。然而，这些密码套件很少使用，特别是在移动应用程序中。</p><p>永远不会调用IOS网络堆栈boringssl_context_certificate_verify_callback()，中的默认BoringSSL回调。这意味着IOS网络堆栈中的某些状态可能未正确设置，这将导致错误。</p><p>最后，还有几件额外的事情我没有时间去做：</p><p>仔细检查我的BoringSSL运行时补丁是否禁用了低级IOS网络API(如Network.framework或CFNetwork)的固定。</p><p>添加对MacOS的支持。我非常确定补丁本身应该可以正常工作，但是我还没有找到在MacOS上挂接BoringSSL(或共享缓存中的任何C函数)的方法。我之前使用的工具Facebook的鱼钩似乎不再起作用了。</p><p>就这样!。转到项目的repo查看代码并下载调整。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nabla-c0d3.github.io/blog/2019/05/18/ssl-kill-switch-for-ios12/">https://nabla-c0d3.github.io/blog/2019/05/18/ssl-kill-switch-for-ios12/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/终止/">#终止</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/kill/">#kill</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ssl/">#ssl</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1003729.html"><img src="http://img.diglog.com/img/2020/5/thumb_55b49a3ff0ecc220a440d5b16f2edf8b.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003729.html">I/O库比FMT快6倍，比stdio.h和iostream快10倍</a></div><span class="my_story_list_date">2020-5-26 5:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1003306.html"><img src="http://img.diglog.com/img/2020/5/thumb_d0f0fd9493c47a6d032f0e61fb5b01d7.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003306.html">iPhone黑客是如何在新iOS发布前几个月拿到它的</a></div><span class="my_story_list_date">2020-5-23 2:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1003152.html"><img src="http://img.diglog.com/img/2020/5/thumb_b3b82e2e5cf040fcbc2df7f2288ad184.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003152.html">冠状病毒接触追踪攻击iOS和iPadOS 13.5的苹果设备</a></div><span class="my_story_list_date">2020-5-22 1:41</span></div><div class="col-sm"><div><a target="_blank" href="/story/1003060.html"><img src="http://img.diglog.com/img/2020/5/thumb_2e5424c30ed0035a344ace4e391283c0.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003060.html">苹果发布带有曝光通知API、Face ID的iOS 13.5</a></div><span class="my_story_list_date">2020-5-21 8:49</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>