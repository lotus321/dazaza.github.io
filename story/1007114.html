<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>纯C语言的代数数据类型和类型自省</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">纯C语言的代数数据类型和类型自省</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-19 00:02:26</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/1f31a07d5f41037126cdbb56e2de1d13.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>唯一的依赖项是Boost/预处理器。如果您在类UNIX系统上，只需运行以下脚本：</p><p>由于poica是一个仅包含头文件的库，因此您可以随意将必要的文件复制到您的项目中，并使用#include&lt；poica.h&gt；导出其API(使用-i编译器选项)。就这些。</p><p>通常在C语言中，我们使用联合来告诉编译器我们将以不同的方式解释单个内存区域。为了决定如何解释并集，我们赋予它一个标记，并得到一个带标记的并集。</p><p>tyecif struct{enum{OUR_TAGGED_UNION_STATE_1，OUR_TAGGED_UNION_STATE_2，OUR_TAGGED_UNION_3，}STATE；UNION{INT STATE_1；CONST char*STATE_2；DOUBLE STATE_3；}DATA；}OurTaggedUnion；</p><p>更糟糕的是，这种方法是不安全的，这意味着我们可以构造无效的OurTaggedUnion(I)，或者，例如，(Ii)当实际状态为OUR_TAGGED_UNION_STATE_3时，(Ii)访问data.state_1：</p><p>//(I)OurTaggedUnion res1={.。STATE=OUR_TAGGED_UNION_STATE_2，。数据。STATE_1=123}；//(Ii)OurTaggedUnion res2={。STATE=OUR_TAGGED_UNION_STATE_3，。数据。STATE_3=。99}；SOME_PROCEDURE(res2.data.state_1)；</p><p>POICA通过引入代数数据类型(将在下一节讨论)解决了这两个问题。这就是POICA如何做到这一点的：</p><p>SUM(OurTaggedUnion，Variant(MkState1 Of Int)Variant(MkState2 of Const char*)Variant(MkState3 Of Double))；//(I)编译失败！OurTaggedUnion res1=MkState2(123)；OurTaggedUnion res2=MkState3(.。99)；SOME_PROCEDURE(/*无法传递STATE_1！*/)；</p><p>ADT(代数数据类型)提供了一种组合、析构和自省数据类型的便捷方法。它们主要有两种：总和型和产品型。</p><p>简单地说，SUM类型是T1、.、TN中的一个，而产品类型是T1、.、TN。SUM类型的另一个名称是标记并集，产品类型对应于C中的结构。</p><p>模式匹配是检查SUM类型的每个变量，如果匹配的变量是实际变量，则触发一些操作。它们类似于IF语句，但适用于SUM类型，而不适用于布尔表达式。</p><p>可以方便地表示为SUM类型，并使用模式匹配进一步操作。在下面的代码中，我们首先构造这个二叉树，然后将它的所有元素打印到stdout：</p><p>#include&lt；poica.h&gt；#include&lt；stdio.h&gt；sum(Tree，Variant(MkEmpty)Variant(MkLeaf Of Int)Variant(多个字段的MkNode(结构树左侧*)字段(Number Of Int)字段(结构树右侧*))；void print_tree(Const Tree*tree){Match(Tree){case(MkEmpty){return；}case(MkLeaf。，*number)；}case(MkNode，More(Left，Number，Right)){PRINT_TREE(*LEFT)；printf(&#34；%d\n&#34；，*Number)；PRINT_TREE(*RIGHT)；}#定义树(树)obj(树的树)#定义节点(左，数，右)树(MkNode(左，数，右))#定义叶(数)树(MkLeaf(数))int main(Void){const Tree*tree=node(node(叶(81)，456，node(叶(90)，7，叶(111)，57，叶(123)；print_tree(Tree)；}#undef tree#undef tree。</p><p>如果我们在C中有结构，为什么我们需要产品类型呢？嗯，因为产品类型提供了一些额外的特性，比如类型自检(在下一节中讨论)和字段提取。</p><p>它计算三角形的面积，如果三条边都已知的话。这可以通过产品类型实现，如下所示：</p><p>#include&lt；math.h&gt；#include&lt；stdio.h&gt；#include&lt；poica.h&gt；product(三角形，字段(A Of Double)字段(B Of Double)字段(C Of Double))；DOUBLE COMPUTE_AREA(三角形){Extract((a，b，c)from(&amp；三角形of Triangle))；const Double p=(a+b+c)/2；const Double Area=sqrt(p*(p-a)*(p-b)*(p-c))；Return Area；}int main(Void){三角形三角形={4，13，15}；printf(&#34；%f\n&#34；，computer_area(三角形))；}</p><p>Extract只创建适当类型的新变量，并从三角形中为它们赋值。将以上代码与此版本的COMPUTE_AREA进行比较：</p><p>DOUBLE COMPUTE_AREA(三角形){CONST DOUBLE P=(三角形。A+三角形。B+三角形。c)/2；常数倍面积=sqrt(p*(p-三角形。a)*(p-三角形。b)*(p-三角形。c))；返回区；}。</p><p>这就是字段提取可以使我们的代码更干净的方式。通常，当对单个变量的字段有大量重复访问时，字段提取是首选的，并且字段对应的变量是显而易见的。</p><p>支持类型自检，因为您可以在编译时查询ADT的类型属性，然后在手写宏中以某种方式处理它们。</p><p>#include&lt；poica.h&gt；#include&lt；stdio.h&gt；#include&lt；Boost/preprocessor.hpp&gt；#定义MY_SUM\SOURCE，\VARIANT(MKA)\VARIANT(int的MKB)\VARIANT(MKC of MAND字段(DOUBLE的c1)字段(CHAR的C2))\SUM(MY_SUM)；#定义Something_Introspect SUM_Introspect(MY_SUM)int main(。</p><p>#include&lt；poica.h&gt；#include&lt；stdio.h&gt；#include&lt；Boost/preprocessor.hpp&gt；#定义MY_PRODUCT\Something，\field(A Of Int)\field(b of const char*)\field(C Of DOUBLE)\product(MY_PRODUCT)；#Define Something_Introspect product_Introspect(MY_PRODUCT)int main(Void){put(BOOST_PP_STRING。</p><p>也就是说，关于类型的元信息实际上是Boost/PreProcessor术语中的一个序列。因此，可以进一步使用BOOST_PP_SEQ_*宏，以及POICA中的其他实用程序宏。</p><p>通过类型自检，可以实现类型驱动(反)序列化、声明性命令行参数解析、修饰器模式等。</p><p>ADT提供了一种安全、一致的错误处理方法。可能失败的过程返回一个SUM类型，指定一个成功或失败的值，如下所示：</p><p>SUM(RecvMsgErrKind，Variant(MkBadConnection)Variant(MkNoSuchUser).)；Sum(RecvMsgRes，Variant(MkRecvMsgOk of char*)Variant(RecvMsgErrKind的MkSendMsgErr)；RecvMsgRes recv_msg(.){.}。</p><p>然后，可以匹配RecvMsgRes以决定在MkRecvMsgOk和MkSendMsgErr的情况下执行什么操作：</p><p>RecvMsgRes res=recv_msg(.)；Match(&amp；res){case(MkRecvMsgOk，msg){.}case(MkSendMsgErr，Err_Kind){.}}。</p><p>可读性。像MkRecvMsgOk和MkSendMsgErr这样的标识符更适合人类，因此，很难将它们相互混淆。与此相反，在C中确定错误的通常方法是使用幻数范围(例如，&lt；0或-1)。</p><p>一致性。不需要发明不同的策略来处理不同类型的错误(例如，对不太可能的错误使用异常，对正常控制流使用int代码，等等)；ADT通常解决错误处理的问题。</p><p>穷尽性检查(案例分析)。智能编译器和静态分析工具可确保RecvMsgRes的所有变体都得到匹配处理，因此我们不能忘记处理错误，让应用程序在没有错误的情况下工作，从而避免可能出现的严重错误。</p><p>ADT甚至比异常更有优势：它们不使用程序堆栈执行转换，因为它们只是值，没有任何可能影响性能的隐式逻辑。</p><p>ADT在实际编程中有大量的应用。例如，将令牌编码为SUM类型、将消息从一个进程传递到另一个进程、计算AST是非常自然的。</p><p>答：POICA没有运行时，也不执行系统调用，宏扩展为纯C代码。以下是示例的反汇编版本：</p><p>答：到目前为止，我发现的唯一陷阱是可怕的宏观错误，描述的是后果，而不是原因。但是，在用户代码中，只需仔细查看触发错误的行号就可以解决这些问题。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/Hirrolot/poica">https://github.com/Hirrolot/poica</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代数/">#代数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>