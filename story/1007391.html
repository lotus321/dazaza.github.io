<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>编译器简介</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">编译器简介</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-20 17:26:48</div><div class="page_narrow text-break page_content"><p>编译器只是一个翻译其他程序的程序。传统编译器将源代码转换为您的计算机能够理解的可执行机器码。(一些编译器将源代码翻译成另一种编程语言。这些编译器称为源到源翻译器或转换程序。)。LLVM是一个广泛使用的编译器项目，由许多模块化的编译器工具组成。</p><p>前端将源代码转换为中间表示(IR)*。clang是LLVM用于C语言家族的前端。</p><p>优化器分析IR并将其转换为更有效的形式。OPT是LLVM优化器工具。</p><p>后端通过将IR映射到目标硬件指令集来生成机器码。LLC是LLVM后端工具。</p><p>*LLVM IR是一种类似于汇编的低级语言。但是，它抽象了特定于硬件的信息。</p><p>下面是一个简单的C程序，它打印“Hello，Compiler！”转到STDOUT。C语法是人类可读的，但是我的计算机不知道如何处理它。我将演练三个编译阶段，使该程序成为机器可执行的。</p><p>//Compile_me.c//向编译器波形。这个世界可以等待。#include&lt；stdio.h&gt；int main(){printf(&#34；Hello，编译器！\n&#34；)；返回0；}。</p><p>正如我在上面提到的，clang是LLVM用于C语言家族的前端。Clang由C预处理器、词法分析器、解析器、语义分析器和IR生成器组成。</p><p>C预处理器在开始转换到IR之前修改源代码。预处理器处理包括外部文件，如上面的#include&lt；stdio.h&gt；。它将用stdio.h C标准库文件的全部内容替换该行，其中将包括printf函数的声明。</p><p>词法分析器(或扫描器或标记器)将字符串转换为单词字符串。每个单词或标记被分配给五个语法类别之一：标点符号、关键字、标识符、字面或注释。</p><p>解析器确定词流是否由源语言中的有效句子组成。在分析令牌流的语法之后，它输出抽象语法树(AST)。Clang AST中的节点表示声明、语句和类型。</p><p>语义分析器遍历AST，确定代码语句是否具有有效含义。此阶段检查类型错误。如果Compile_me.c中的main函数返回&#34；ZERO&#34；而不是0，语义分析器将抛出错误，因为&#34；ZERO&#34；不是INT类型。</p><p>；llvm_ir.ll@.str=私有UNNAME_ADDR常量[18 x i8]c&#34；Hello，编译器！\0A\00&#34；，Align 1定义I32@Main(){%1=alloca I32，Align 4；&lt；-堆栈存储上分配的内存I32 0，I32*%1，ALIGN 4%2=调用I32(i8*，.)@printf(i8*getelementptr inbound([18 x i8]，[18 x i8]*@.str，I32 0，I32 0))ret I32 0}声明I32@printf(i8*，.)。</p><p>优化器的工作是基于对程序运行时行为的理解来提高代码效率。优化器将IR作为输入，并生成改进的IR作为输出。LLVM的优化器工具opt将使用标志-O2(大写o，2)优化处理器速度，并使用标志-Os(大写o，s)优化大小。</p><p>看看我们的前端在上面生成的LLVM IR代码与运行结果之间的差异：</p><p>；Optimized.ll@str=private unnamed_addr常量[17 x i8]c&#34；Hello，编译器！\00&#34；定义I32@main(){%put=尾部调用I32@put(i8*getelementptr inbound([17 x i8]，[17 x i8]*@str，i64 0，i64 0))ret I32 0}声明I32@put(i8*nocatch只读)</p><p>在优化版本中，main不在堆栈上分配内存，因为它不使用任何内存。优化后的代码还调用put而不是printf，因为没有使用printf的任何格式化功能。</p><p>当然，优化器不仅仅知道何时使用put代替printf。优化器还会展开循环并内联简单计算的结果。考虑下面的程序，它将两个整数相加并打印结果。</p><p>//add.c#include&lt；stdio.h&gt；int main(){int a=5，b=10，c=a+b；printf(&#34；%i+%i=%i\n&#34；，a，b，c)；}。</p><p>@.str=私有UNNAME_ADDR常量[14 x i8]c&#34；%i+%i=%i\0A\00&#34；，Align 1定义I32@main(){%1=alloca I32，Align 4；&lt；-为变量a分配堆栈空间%2=Alloca I32，Align 4；&lt；-为var b%3分配堆栈空间%3=alloca I32，Align 4；&lt；-为内存位置%1的变量c存储I32 5、I32*%1、Align 4；分配堆栈空间；-在内存位置%1的存储5存储I32 10、I32*%2、Align 4；&lt；-在内存位置%2的存储10%4=加载I32、I32*%1、Align 4；&lt；-将内存地址%1处的值加载到寄存器%4%5=加载I32、I32*%2、Align 4；&lt；-将内存地址%2处的值加载到寄存器%5%6=ADD NSW I32%4，%5；&lt；-将寄存器%4和%5中的值相加。将结果放入寄存器%6存储I32%6，I32*%3，ALIGN 4；&lt；-将寄存器%6的值加载到内存地址%3%7=加载I32，I32*%1，ALIGN 4；&lt；-将内存地址%1处的值加载到寄存器%7%8=加载I32，I32*%2，ALIGN 4；&lt；-将内存地址%2处的值加载到寄存器%8%9=加载I32，I32*%3，ALIGN 4；&lt；-将内存地址%3处的值加载到寄存器%9%10=调用I32(i8*，.)@printf(i8*getelementptr inbound([14 x i8]，[14 x i8]*@.str，I32 0，I32 0)，I32%7，I32%8，I32%9)ret I32 0}声明I32@printf(i8*，.)。</p><p>@.str=私有unname_addr常量[14 x i8]c&#34；%i+%i=%i\0A\00&#34；，Align 1定义I32@Main(){%1=Tail调用I32(i8*，.)@printf(i8*getelementptr inbound([14 x i8]，[14 x i8]*@.str，i64 0，i64 0)，I32 5，I32 10，I32 15)ret I32 0}声明I32@printf(i8*nocatch readonly，.)。</p><p>我们优化的主函数实质上是未优化版本的第16和17行，变量值是内联的。OPT计算加法是因为所有变量都是常量。很酷，是吧？</p><p>LLVM的后端工具是LLC。它分三个阶段从LLVM IR输入生成机器码：</p><p>指令选择是将IR指令映射到目标机器的指令集。此步骤使用虚拟寄存器的无限命名空间。</p><p>寄存器分配是将虚拟寄存器映射到目标体系结构上的实际寄存器。我的CPU采用x86架构，最多只能有16个寄存器。但是，编译器将使用尽可能少的寄存器。</p><p>指令调度是对操作的重新排序，以反映目标机器的性能约束。</p><p>_main：PUSQ%RBP movq%rsp，%RBP leaq L_str(%rip)，%RDI callq_put xorl%eax，%eax popq%rbp retqL_str：.asciz&#34；您好，编译器！&#34；</p><p>这个程序是x86汇编语言，这是我的计算机所说语言的人类可读语法。终于有人理解我了，🙌</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nicoleorchard.com/blog/compilers">https://nicoleorchard.com/blog/compilers</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/intro/">#intro</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/i32/">#i32</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1007158.html"><img src="http://img.diglog.com/img/2020/6/thumb_dde71b18b31374e668d369cd8c5ee2ef.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1007158.html">编译器编译器：关于使用JavaScript引擎的Twitch系列文章</a></div><span class="my_story_list_date">2020-6-19 3:23</span></div><div class="col-sm"><div><a target="_blank" href="/story/1007138.html"><img src="http://img.diglog.com/img/2020/6/thumb_7583c582a09ba5fcac7604ae2baefec2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1007138.html">编译时合并排序[C++]</a></div><span class="my_story_list_date">2020-6-19 2:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1006819.html"><img src="http://img.diglog.com/img/2020/6/thumb_64f792b778acfccbf5f64e6ca4044b24.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1006819.html">铁锈编译器不慢，我们慢</a></div><span class="my_story_list_date">2020-6-16 23:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005598.html"><img src="http://img.diglog.com/img/2020/6/thumb_4b7d9ecba1881eda1176c27aaa7da297.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005598.html">蜂鸟：将训练好的ML模型编译成张量计算</a></div><span class="my_story_list_date">2020-6-8 2:33</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>