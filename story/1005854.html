<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Prisma 2.0：让您的数据库充满信心，提高工作效率</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Prisma 2.0：让您的数据库充满信心，提高工作效率</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-09 22:51:30</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/d20f3562dccf21a6d1fc97ba23016042.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>现有的数据库访问库范围从发送原始SQL字符串到更高级别的抽象(如SQL查询构建器和ORM)。这些方法中的每一种都有自己的问题和陷阱。总体而言，在Node.js和TypeScript中使用数据库的应用程序开发人员缺乏最佳实践。</p><p>Prisma是一个开源数据库工具包。它取代了传统的ORM，并使用针对Node.js和TypeScript的自动生成的、类型安全的查询构建器简化了数据库访问。</p><p>Prisma目前支持PostgreSQL、MySQL和SQLite数据库-还有更多计划中的数据库。如果您想查看对特定数据库的支持，请创建新的GitHub版本或订阅现有版本(例如MongoDB或DynamoDB)。</p><p>在运行了Prisma2.0的预览版和测试版将近一年之后，并从我们的社区收集了大量有用的反馈，我们很高兴能够推出Prisma Client for General Availability🎉。</p><p>Prisma Client为开发人员提供了一种全新的访问数据库的方式，并且牢记两个主要目标：</p><p>在本节中，我们将更仔细地了解Prisma Client如何使开发人员能够更快地构建应用程序，同时编写更具弹性和健壮性的代码。</p><p>Prisma客户端的最大好处之一是它提供的抽象级别。它允许开发人员在对象(而不是SQL)中考虑他们的数据，减少了将关系数据映射到面向对象数据的认知和实际开销。</p><p>虽然Prisma客户端将数据作为对象返回，但它不是ORM，因此不会受到对象关系阻抗不匹配经常导致的常见问题的困扰。</p><p>Prisma不会将类映射到表，也不会像传统ORM中经常看到的那样，存在复杂的模型实例或隐藏的性能陷阱(例如，由于延迟加载)。Prisma客户端为您的数据库模式提供了一个查询API，重点放在结构类型和自然查询上(从这个意义上说，它最接近传统ORM的数据映射器模式)。</p><p>使用Prisma Client，您可以制定如下查询来读取和写入这些表中的数据：</p><p>如您所见，生成的postsByAuthor包含一个纯JavaScript对象数组(如果您正在使用typecript，这些对象将是强类型的)。您还可以轻松地包括模型的关系，在这种情况下，您还可以检索关于返回帖子的&#34；作者&#34；的信息：</p><p>const postsByAuthorWithAuthorInfo=等待Prisma.post。findMany({where：{Author：{id：42}}，include：{Author：true，}})。</p><p>再次注意，在使用TypeScript时，postsByAuthorWithAuthorInfo中的对象是完全类型化的，因此访问POST作者的不存在属性(在本例中)将引发编译器错误。</p><p>使用现有数据库工具访问相关数据(即通过外键连接的表中的数据)可能特别棘手。这主要是由于这些关系在关系数据库和面向对象语言中的表示方式根本不匹配：</p><p>关系：数据通常是标准化(平面)的，并使用外键跨实体进行链接。然后需要联接这些实体以显示实际的关系。</p><p>面向对象：对象可以是深度嵌套的结构，您只需使用点符号就可以遍历关系。</p><p>const result=等待Prisma.user。findMany({include：{post：{select：{id：true，title：true})。</p><p>再次注意，在上述所有情况下，如果您使用的是TypeScript！</p><p>使用SQL(例如CREATE TABLE USER、ALTER TABLE USER ADD COLUMN EMAIL)读取表和其他数据库结构的定义可能会。Prisma引入了称为Prisma模式的数据库模式的声明性版本。</p><p>Prisma模式是通过自省数据库生成的，它是Prisma客户端查询API的基础。例如，这是上述用户和发布定义的等效版本：</p><p>model{id Int@default(autoincremental())@id电子邮件字符串@唯一名称字符串？Posts Post[]}model{id Int@default(autoincremental())@id标题字符串内容字符串？Author User@Relationship(字段：[Author ID]，引用：[ID])Author ID Int}。</p><p>注意：我们还在开发一个名为Prisma Migrate的数据库迁移工具。使用Prisma Migrate，基于自省的工作流被颠倒，您可以将声明性Prisma架构映射到数据库；Prisma Migrate将生成所需的SQL语句，并针对数据库执行这些语句。</p><p>自动完成是一个非常强大的功能，它使开发人员能够在其编辑器中探索API，而不是查找参考文档。因为Prisma客户机是从您的数据库模式生成的，所以您会对查询API感到非常熟悉。</p><p>拥有自动完成功能在很大程度上有助于提高工作效率，因为您可以边使用边学习API。自动完成功能还可以增强您的信心，因为您可以确保建议的API操作能够正常工作。</p><p>Prisma客户端保证所有数据库查询的完全类型安全，即使只检索模型属性的子集或使用include加载关系也是如此。</p><p>再次考虑前面示例中的USER和POST表，PRISMA生成以下类型的文字脚本来表示应用程序中这些表的数据：</p><p>类型user={id：number email：string name：string|null}类型Post={id：number AuthId：number|null title：string|null content：string|null}。</p><p>Prisma客户端发送的任何纯CRUD查询都将返回相应键入的对象的响应。但是，再次考虑上面的查询，其中使用include来获取关系：</p><p>const postsByAuthorWithAuthorInfo=等待Prisma.post。findMany({where：{Author：{id：42}}，include：{Author：true，}})。</p><p>postsByAuthorWithAuthorInfo中的对象与生成的Post类型不匹配，因为它们携带附加的Author对象。在这种情况下，Prisma客户端仍然提供完全的类型安全，并且能够静态键入结果！以下是该类型的外观：</p><p>多亏了这一点，TypeScript编译器将捕捉您再次访问不存在的属性的情况。例如，这将是非法的：</p><p>数据库工具通常存在需要在应用程序代码和数据库之间同步对数据模型所做的更改的问题。例如，在更改数据库表之后，开发人员通常需要在其应用程序代码中手动调整各自的模型，并扫描代码库以查找表的用法以更新它。</p><p>这使得数据库模式迁移和代码重构变得可怕，因为不能保证这两个层在更改后保持同步！</p><p>Prisma客户端对此问题采取了不同的方法。Prisma客户端的查询API是基于您的数据库架构生成的，而不是手动同步应用程序代码和数据库之间的更改。</p><p>使用这种方法，您只需在数据库模式更改后重新生成Prisma客户端，更改将自动同步到您的Prisma客户端查询API。多亏了自动完成和类型安全，将应用程序代码更新为新查询比使用任何其他方法都要快得多。</p><p>Prisma的主要用例是构建需要在数据库中持久化数据的服务器端应用程序。</p><p>自从Prisma2.0的预览阶段以来，我们已经看到开发人员构建了广泛的应用程序，从社交网络应用程序到电子商务商店，再到生产力工具和市场。我们很高兴看到你和普里斯玛一起建造了什么！</p><p>到目前为止，这是我职业生涯中开发得最快的一次。Prisma极大地缩短了实现时间，同时增加了人们对我的代码的信心。我还能够对许多新的增量功能说“是”；现在需要半天时间才能实现一些过去需要两三个人才能完成的事情。</p><p>服务器端应用程序通常公开由前端(例如，Web或移动)或其他应用程序使用的API。Prisma客户端兼容所有现有的API技术，如REST、GraphQL、Thrift或GRPC。</p><p>PRISMA客户端可用于传统的单片服务器、微服务体系结构和无服务器部署。请阅读有关部署的文档页面以了解更多信息。</p><p>尽管Prisma还很年轻，但我们对新兴的生态系统和我们看到的围绕它生长的各种工具感到非常自豪和兴奋。</p><p>js生态系统以许多不同的框架而闻名，这些框架试图简化工作流并规定某些约定。许多框架作者决定使用Prisma作为他们选择的数据层，我们对此感到非常谦卑。</p><p>由GitHub联合创始人Tom Preston-Werner创建的新Redwood JS框架试图成为Node.js的Ruby on rails版。Redwood JS基于React和GraphQL，并附带了用于无服务器功能的内置部署模型。</p><p>另一个在社区中越来越受期待和兴奋的框架是Blitz.js。闪电战构建在Next.js之上，与Redwood相比，它采取了一种与Redwood完全不同的方法。它的目标是完全消除API服务器，恢复服务器渲染框架的简单性。</p><p>在Prisma，我们是GraphQL的超级粉丝，并相信它的光明未来。这就是为什么我们成立了Prisma实验室团队，他们致力于在GraphQL生态系统中开发开源工具。</p><p>它目前专注于构建Nexus，这是一个用于开发GraphQL服务器的令人愉快的应用程序框架。与Redwood相反，Nexus是一个仅限后端的GraphQL框架，对于如何从前端访问GraphQL API没有任何意见。</p><p>使用Nexus的Prisma插件，您可以在GraphQL API中公开Prisma模型，而无需实现将GraphQL解析器连接到数据库时所需的典型CRUD样板。</p><p>model{id Int@default(autoincremental())@id电子邮件字符串@唯一名称字符串？Posts Post[]}model{id Int@default(autoincremental())@id标题字符串内容字符串？Author User@Relationship(字段：[Author ID]，引用：[ID])Author ID Int}</p><p>多亏了这个插件，几乎不需要任何样板就可以为Prisma模型公开完整的CRUD操作，包括过滤器、分页和订购功能。</p><p>快速入门(5分钟)了解如何使用Prisma客户端针对演示SQLite数据库发送数据库查询-无需设置！</p><p>3月份测试版的积极反响让我们不知所措，我们很高兴能与大家分享今天的正式发布！非常感谢每一个陪伴我们走过这段旅程的人！</p><p>如果你是新来普里斯马的，我们很乐意看到你坐在我们的“松弛”车里！如果您已经在使用Prisma，请在#Showcase频道中发布您构建的内容，让每个人都知道。</p><p>我们为我们的内容创作者社区感到自豪，他们创造了许多关于Prisma的精彩文章和视频！有关最佳Prisma资源的概述，请查看AWOWE-Prisma repo。别忘了创建一个公关，里面有任何遗漏的东西！</p><p>继去年首映成功后，我们很高兴能在6月25日(工作坊)和26日(讲座)举办另一版的棱镜日。</p><p>今年，我们将远程访问，并邀请每个人与我们一起围绕现代应用程序开发、数据库工作流的最佳实践以及Prisma的一切内容进行精彩的演讲！</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.prisma.io/blog/n0v98rzc8br1/">https://www.prisma.io/blog/n0v98rzc8br1/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/充满信心/">#充满信心</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/prisma/">#prisma</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1005825.html"><img src="http://img.diglog.com/img/2020/6/thumb_fccf902dc5dcd5d37539b962a2ea371d.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005825.html">RecallGraph-一个开放源码的图形数据库，用于版本控制的图形数据</a></div><span class="my_story_list_date">2020-6-9 16:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1005700.html"><img src="http://img.diglog.com/img/2020/6/thumb_30c0609340e60cb418e40054d8c080af.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1005700.html">数据库“分片”来自UO？(2009)</a></div><span class="my_story_list_date">2020-6-8 22:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1004984.html"><img src="http://img.diglog.com/img/2020/6/thumb_9a97d32d3d1640d4e6e9ffaeab4b1f5c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004984.html">带异步主从复制的PostgreSQL自动群集</a></div><span class="my_story_list_date">2020-6-3 21:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1004491.html"><img src="http://img.diglog.com/img/2020/5/thumb_ac5f9f642e22ec6aa5b2517f780059bf.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004491.html">BeeKeeper Studio是一个免费的开源SQL编辑器和数据库管理器</a></div><span class="my_story_list_date">2020-5-31 13:16</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>