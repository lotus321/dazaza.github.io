<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Common Lisp控制终端(第2部分)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">从Common Lisp控制终端(第2部分)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-20 02:18:23</div><div class="page_narrow text-break page_content"><p>这是关于从零开始为终端构建McCLIM后端的教程的第二部分。读完第一期后，我们应该很好地掌握如何控制和读取来自终端的输入。为了提高效率和易用性，现在是时候改进一下了。如果你没有读完最后一部分，这里是包含源代码的归档文件，它将作为这篇文章的起点。</p><p>目前，我们的I/O与终端同步。当我们调用outor ctl时，字符立即被发送到它，并且我们使用read-input读取输入，直到流为空。上一篇文章中介绍的模型当然很简单，但是简单的模型很难有效地使用。我们将把重点放在“简单”上。在这篇文章中，我将把重点放在输出上。</p><p>计算机科学中的所有问题都可以通过另一个层次的方向来解决。--大卫·惠勒。</p><p>我们将为编写控制台应用程序构建一个方便的抽象。然而，如果我们放弃直接操纵航站楼的手段，那将是一种耻辱。该库将提供不同的API，因此可以迎合程序员的需要。原则上，同时使用两个不同的抽象是不可行的，因为较高的抽象建立在较低的抽象之上，事情可能会出错。</p><p>现在，我们将定义两个包：eu.turtleware.charming-clim/l0和eu.turtleware.charming-Climate.Terminal/L1，它们具有不同的抽象级别来访问终端。它们只是作为导出符号的手段，所有的实现都在一个包中完成，这种做法极大地提高了使用Common Lisp包的人的生活质量。现在创建文件Packages.lisp。</p><p>(defpackage#：eu.turtleware.charming-clim/l0(：export#：init-Terminal#：关闭终端#：*Terminal*#：put#：esc#：csi#：sgr#：读取输入#：keyp#：复位终端#：清除终端#：清除行#：设置前景颜色#：设置背景颜色#：带有光标位置#：设置光标位置#：保存光标。-Position#：Restore-Cursor-Position#：Request-Cursor-Position#：Cursor-Up#：Cursor-Down#：Cursor-Right#：Cursor-Left#：Set-Cursor-Visibility#：Set-Mice-Tracking)(defpackage#：eu.turtleware.charming-clim/L1(：export#：with-console#：out#：ctl))(defpackage#：eu.turtleware.charming-clim(：use#：common。-LISP#：eu.turtleware.charming-clim/l0#：eu.turtleware.charming-clim/L1)。</p><p>我们将利用这个机会使函数命名更加一致，并介绍光标操作实用程序。重命名函数。</p><p>并添加用于操作光标的转义序列。不要忘记在代码的其他部分(在宏ctl和函数initialize-instance、(SETF PTR)和(SETF CVP)中)更改对重命名函数的引用。</p><p>(Maclet((moveit(Endch)`(if(=n 1)(csi，endch)(csi，endch)(csi n，endch)(deful sor-up(&amp；可选(N 1))(moveit&#34；A&#34；))(deun sor-down(&amp；可选(N 1))(moveit&#34；B&#34；))(deful sor-right(&amp；可选(N 1))(moveit&#34；C&#34；))(def Cursor-Left(&amp；Optional(N 1))(moveit&#34；D&#34；))(deun设置光标可见性(Visiblep)(if visiblep(csi&#34；？&#34；2 5&#34；h&#34；)(csi&#34；？&#34；2 5&#34；l&#34；)(csi&#34；？&#34；2 5&#34；l&#34；；；(CSI？跟踪；编码h/l)；跟踪：1000-正常，1002-按钮，1003-所有动作；1004-焦点输入/输出；编码：1006-SGR编码方案(deFun设置-鼠标跟踪(Enabledp)(如果启用)(如果启用)p(csi&#34；？&#34；1003&#34；；&#34；1006&#34；h&#34；)(csi&#34；？&#34；1003&#34；)(CSI&#34；？&#34；？&#34；1003&#34；)(CSI&#34；？&#34；？&#34；1003&#34；)(deFun set-alt-is-meta(Bool)(if bool(setf+alt-mod++meta-mod+)(setf+alt-mod++alt-mod*+)。</p><p>从现在开始，当我们谈论低级抽象时，我们将把目标对象称为终端，而当我们谈论高级抽象时，我们将把它的目标对象称为控制台。重命名以下符号。</p><p>并替换源代码中的所有引用以使用新符号。将变量*TERMINAL*和函数INIT-TERMINAL和CLOSE-TERMINAL移到顶部(外来函数定义下方)。</p><p>我们将略微重构集合-*-颜色函数。函数将使用表示颜色RGBA值的数字，而不是单独接受每种颜色。例如#ff000000表示红色。现在将忽略字母表，但拥有此组件将省去数据表示格式的另一次更改。</p><p>(DeFun Set-前景色(COLOR)(让((r(LDB&#39；(8.。24)颜色))(g(LDB&#39；(8.。16)颜色))(b(LDB&#39；(8.。8)颜色)(a(LDB&#39；(8.。0)color)(DECLARE(忽略a))(sgr&#34；38；2；&#34；r&#34；；&#34；g&#34；；&#34；b)(deFun set-back-color(Color)(let((r(LDB&#39；(8.。24)颜色))(g(LDB&#39；(8.。16)颜色))(b(LDB&#39；(8.。8)颜色)(a(LDB&#39；(8.。0)color)(声明(忽略a))(sgr&#34；48；2；&#34；r&#34；；&#34；g&#34；；&#34；b))。</p><p>(def宏ctl(&amp；REST操作)`(#|.|#(：fgc`(setf(fgc*console*)，@args))(：bgc`(setf(bgc*console*)，@args)(defclass console()#|.|#(：default-initargs：fgc#xffa0a000：bgc#x222200))(defmethod initialize-instance：After(实例控制台)&amp。key FGC BGC pos CVP PTR)#|.|#(设置前景色FGC)(设置背景色BGC)(defmethod(SETF FGC)：After(RGBA(实例控制台))(设置前景色RGBA))(defmethod(SETF BGC)：After(RGBA(实例控制台))(设置背景色RGBA))(deFun show-Screen()#|.|#(out。：bgc#x00000000：fgc#xbb000000))(out(：bgc#x00000000：fgc(亚历山大：Random-ELT&#39；(#x00444400#x00444400#x00664400)。</p><p>现在，我们将按以下顺序将与控制台相关的部件移动到单独的文件console.lisp：</p><p>最后，示例代码将放在文件example.lisp中。移动功能在那里显示屏幕和开始显示。</p><p>(defsystem&#34；eu.turtleware.charming-clim&#34；：defsystem-Dependent-on(#：CFFI)：Depends-on(#：Alexandria#：CFFI#：Swank)：Components((：cfile&#34；raw-mode&#34；)(：file&#34；Packages&#34；)(：file&#34；Terminal&#34；：Depends-on(&#34；Packages&#34；)(：文件&#34；控制台&#34；：依赖于(&#34；包&#34；&#34；终端&#34；))(：文件&#34；示例&#34；：依赖于(&#34；包&#34；&#34；控制台&#34；))。</p><p>Console对象有很多职责，因此重构它以继承仅实现与输出相关的部分的类是有意义的。当我们决定添加另一层间接层时，这也会很有用。在实现缓冲区时，我还会将一个不合适的位置表示固定为cons，并指定剪辑区域。创建文件output.lisp并将其添加到ASD文件。</p><p>(defsystem&#34；eu.turtleware.charming-clim&#34；：defsystem-Dependent-on(#：CFFI)：Depends-on(#：Alexandria#：CFFI#：Swank)：Components((：cfile&#34；raw-mode&#34；)(：file&#34；Packages&#34；)(：file&#34；Terminal&#34；：Depends-on(&#34；Packages&#34；)(：文件&#34；输出&#34；：依赖于(&#34；包&#34；))(：文件&#34；包&#34；控制台&#34；依赖于(&#34；包&#34；&#34；输出&#34；&#34；终端&#34；))(：文件&#34；示例&#34；：依赖(&#34；包&#34；&#34；控制台&#34；()。</p><p>宏out和ctl将在当前虚拟缓冲区上操作。为了做到这一点，我们将定义一个必须由所有虚拟缓冲区实现的协议。With-Clip现在变成了一种方便的宏扩展为通用函数Invoke-with-Clip。引入一个带-Buffer的宏来绑定当前缓冲区，该缓冲区绑定到变量*Buffer*。</p><p>(defGeneric PUT-CELL(缓冲区行列fg bg))(defGeneric FGC(Buffer))(defGeneric(SETF FGC)(FGC Buffer)(：参数优先顺序缓冲区FGC))(defGeneric BGC(Buffer))(defGeneric(SETF BGC)(BGC Buffer)(：参数优先顺序缓冲区BGC))(defGeneric行(缓冲区))(defGeneric(SETF行)(行缓冲区)(：参数-。优先顺序缓冲行))(defGeneric列(缓冲区))(defGeneric(集合列)(列缓冲区)(：自变量优先顺序缓冲区列))(defGeneric行(缓冲区))(defGeneric Inside-p(缓冲区行))(defGeneric Inside-p(缓冲区行))(defGeneric Inside-With-Clip(缓冲区延续&amp；REST选项&amp；key r1 c1 R2 c2 fn)(带-CLIPPING的def宏((缓冲区&amp；REST选项)&amp；Body Body)(let((fn(Gensym)`(Flet((，fn()，@body)(DECLARE(Dynamic-Extension(function，fn)(Invoke-with-clipping，buffer(function，fn)，@opts)(defvar*buffer*)(def宏with-buffer((Object)&amp；Body Body)`(let((*buffer*，object))，@body)。</p><p>下面用这些术语实现CTL和OUT宏。我们将暂时从ctl宏中省略：cvp和：ptr选项。LETF和Clear-Rectangle保持不变。从console.lisp文件中删除旧宏。</p><p>(def宏letf(binings&amp；Body)(LOOP FOR(Place Value)in Bindings for old-val=(Gensym)Collect`(，old-val，place)into save Collect`(setf，place，value)into store Collect`(setf，place，old-val)into Restore Final)(return`(let(，@save)(Unwind-Protect(pron，@store，@body)，@restore)(def宏out((&amp；键行列FGC BGC)对象)`(let((buf*buffer*)(str(princ-to-string，object)(assert(NULL(find#\newline str)(letf(Row Buf)(or，row(Row Buf)((Colbuf)(or，col(Colbuf)((FGC Buf)(or，FGC(FGC Buf)((BBGC。bgc(Bgc Buf)(LOOP with row=(Row Buf)for colfrom(Colbuf)for ch over str with bgc=(Bgc Buf)with fgc=(Fgc Buf)do(put-cell buf row colch fgc bgc)(def宏ctl(&amp；REST操作)`(let((buf*buffer*))，@(COLLECT操作中的OP循环(析构-绑定(name&amp；REST ARGS)OP(ECASE NAME(：clr`(clear-rectangle，@args))(：fgc`(setf(Fgc Buf)，@args))(：bgc`(setf(Bgc Buf)，@args))(：row`(setf(Row Buf)，@args))(：col`(setf(Colbuf)，@args)(defun清除-矩形(R1c1r2c2)(带str=(make-string(1+(-c2c1))：首字母元素#\space)表示r从r1到r2do(OUT(：ROW r：COL c1)str))。</p><p>如果没有实现，协议会是什么呢？裁剪将通过类Clip实现。此选择是透明的，因为所有函数都是在缓冲区上专用的。每个缓冲区都有其自己的裁剪区域。虚拟缓冲区不知道如何在屏幕上绘制，所以put-cell会打印警告。</p><p>(defclass bbox()((r1：initarg：r1：存取器r1)(c1：initarg：c1：存取器c1)(r2：initarg：r2：存取器R2))(c2：initarg：c2：存取器c2))(declass Clip(Bbox)((fn：initarg：fn：存取器fn))(：default-initargs：r1 1：c1：r2 24：C2 80：fn。(常量t)(defclass buffer()((fgc：initarg：fgc：存取器fgc：Documentation&#34；前面的颜色&#34；)(bgc：initarg：bgc：存取器bgc：Documentation&#34；背景颜色&#34；)(row：initarg：row：存取器行：Documentation&#34；当前行&#34；)(ol：initarg：COL：存取器列：Documentation&#34；当前列&#34；)(Clip：initarg：Clip：Accessessor Clip：Documentation&#34；裁剪对象&#34；)(Clip：initarg：Clip：Accessor Clip：Documentation&#34；Clip Object&#34；))(ROWS：initarg：ROWS：存取器行：Documentation&#34；缓冲区行数&#34；)(COLS：initarg：COLS：存取器COLS：Documentation&#34；缓冲区&#34；))(：default-initargs：Clip(make-instance&#39；Clip))(Defmethod put-cell((Buffer)row colch FG BG)(warn&#34；put-cell：default method不做任何事情！&#34；PUT-CELL：DEFAULT方法不做任何事情！&#34；PUT-CELL：DEFAULT方法不做任何事情！&#34；)(defmethod inside-p((缓存)行缓存)(let((剪辑(剪辑缓存)(和(&lt；=(r1剪辑)行(r2剪辑))(&lt；=(c1剪辑)列(c2剪辑))(funcall(fn剪辑)行列)(defmethod call-with-clipping((Buffer)cont&amp；密钥r1c1R2 c2fn)(let((剪辑(剪辑缓冲区)(let((old-r1(r1剪辑))(old-c1(c1剪辑))(old-R2(r2剪辑))(old-c2(c2剪辑))(old-fn(fn剪辑)(SETF(r1剪辑)(max(或r1old-r1)old-r1)(c1剪辑)(max(或c1剪辑)。old-c1)(r2剪辑)(min(或r2old-r2)old-r2)(c2剪辑)(min(或c2 old-c2)old-c2)(fn剪辑)(if(NULL Fn)old-fn(λ(行列)(AND(funcall fn行列)(funcall old-fn行列)(展开保护(Funcall Cont)(SETF(r1剪辑)old-r1。(c1剪辑)old-c1(R2剪辑)old-R2(c2剪辑)old-c2(fn剪辑)old-fn)。</p><p>最后，我们可以修改Console类本身。带有-console的宏单独绑定了一个缓冲区，因此我们可以同时访问输出缓冲区和控制台。</p><p>(def宏with-console((&amp；rest args&amp；key IOS FGC BGC CVP fps&amp；Allow-Other-Key)&amp；Body Body)(DECLARE(忽略FGC BGC CVP fps))`(let*((*Terminal*，iOS)(*console*(make-instance&#39；console，@args)(展开保护(with-buffer(*console*)，@body)(关闭终端(hnd*console*)。</p><p>(defunUPDATE-CONSOLE-DIMEMS()(WITH-CURSOR-POSITION((EXPT 216)(EXPT 216))(Multiple-Value-Bind(ROWS COLS)(GET-CURSOR-POSITION)(SETF(ROWS*CONSOLE*)ROWS)(SETF(COLS*CONSOLE*)COLS)(SETF(R2(CLIP*CONSOLE*))ROWS)(SETF(c2(CLIP*CONSOLE*))COLS))。</p><p>并且类控制台本身被重塑为从类缓冲区继承。请注意，我们去掉了位置和应用程序插槽。</p><p>(defclass控制台(缓冲区)((IOS：initarg：IOS：存取器IOS：Documentation&#34；控制台I/O流。&#34；)(cvp：initarg：cvp：存取器cvp：Documentation&#34；光标可见性。)(ptr：initarg：ptr：存取器ptr：Documentation&#34；指针跟踪。&#34；)(fps：initarg：fps：存取器fps：Documentation&#34；)。)(hnd：访问器hnd：Documentation&#34；终端处理程序。&#34；))(：default-initargs：IOS(错误&#34；必须指定I/O流。&#34；)：fgc#xffa0a000：bgc#x222200：行1：列1：cvp nil：ptr t：fps 10)(defmethod initialize-instance：After(实例控制台)&amp；Key FGC BGC行列CVP PTR)(SETF(HND实例)(初始化终端))(设置前景色FGC)(设置背景色BGC)(设置光标位置行列)(设置光标可见性CVP)(设置鼠标跟踪PTR)(let((*控制台*实例))(更新控制台维度))(defmethod(SETF FGC)：After(RGBA(实例控制台))(设置前景。-color RGBA))(defmethod(SETF BGC)：After(RGBA(实例控制台))(set-back-color RGBA))(defmethod(SETF Row)：After(row(实例控制台))(设置游标位置行为空)(defmethod(SETF Column)：After(ol(实例控制台))(Set-Cursor-Position nil ol))(defmethod(SETF PTR)：After(PTR(实例控制台))。))(set-鼠标跟踪(not(Null Ptr)(defmethod(Setf Cvp)：After(cvp(实例控制台))(set-Cursor-Visibility(not(Null Cvp)。</p><p>将单元格放到屏幕上需要先设置光标位置和单元格颜色，然后调用函数put。函数put-cell负责验证该单元是否在裁剪区域内。</p><p>(defmethod put-cell((缓冲控制台)行列fg bg)(WHEN(内部-p缓冲行列)(设置光标位置行列)(设置前景色fg)(设置背景色bg)(Put Ch)</p><p>最后，我们需要考虑with-clipping宏中的更改，将缓冲区作为第一个参数传递，并删除对app访问器的引用。修改功能显示画面：</p><p>(deFun show-screen()(loop for ch=(read-input)Until(Null Ch)do(cond((keyp ch#\q：c)(cl-user：：Quit)((keyp ch#\u：c)(Ignore-Errors(user-action)(Flet((ll(行列)(or(or(and(&lt；(ABS(-(+列)26))2)(&lt；=列20))(&lt；(abs(-(+(-40列)行)26))2)(带-剪裁(*缓冲*：fn#&#39；L：r1 2：r2 11)(OUT(：ROW(1+(随机12))：COL(1+(随机40))：bgc#x00000000：fgc#xbb000000)(亚历山大：Random-ELT&#39；(&#34；X&#34；&#34；O&#34；)(With-Clip(*Buffer*：fn(lambda(行列)(或(=行1)(=行12)(funcall(补码#&#39；11)行列)(OUT(：行(1+(随机12))：COL(1+(随机40))：bgc#x00000000：fgc(亚历山大：随机ELT&#39；(#x00444400#x00444400#x00664400)(亚历山大：Random-ELT&#39；(&#34；+&#34；-&#34；)。</p><p>所有这些更改都是非常有侵入性的，因此请确保重新启动映像并再次尝试运行应用程序，以确保一切仍然正常。</p><p>是时候编写一个新的示例应用程序了。坐着别动，我们在写窗口管理器！为了与CLIM术语兼容，我们称它为帧管理器。每个应用程序将由其边界框和呈现函数定义的帧表示。</p><p>(defclass frame-manager()((Frames：initarg：Frames：Accessor Frame：Documentation&#34；All Frame&#34；)(active：initarg：active：Active：Active Frame：Documentation&#34；Active Frame&#34；))(：default-initargs：frame nil：active nil))；haha，完全不是剪辑。(Defclass Frame(Bbox)((fn：initarg：fn：存取器fn))(：default-initargs：r1 1：c1 1：r2 24：C2 80：fn(常量t)。</p><p>显示帧涉及在启用剪裁的情况下调用呈现函数，并显示装饰。通常单元格的宽度小于其高度，因此如果我们想要节省一些空间，在应用程序一侧将装饰绘制为竖条更有意义。这就是我们要做的。活动框架将用不同的侧栏颜色表示。</p><p>(去趣化渲染应用程序(fm帧)(with-clipping(*buffer*：r1(r1帧)：c1(c1帧)：R2(R2帧)：C2(c2帧))(funcall(fn帧)(去趣化渲染装饰(fm帧)(声明(忽略fm))(循环，用于第(1+(c2帧))至(1+(c2帧))的行)(去趣味渲染-应用程序(fm帧)(with-clipping(*buffer*：r1帧)：c1(c1帧))：R2(R2帧)：(funcall(fn帧)。1-(R2帧))DO(OUT(：ROW：COL COL)&#34；&#34；)最后(OUT(：COLCOL：ROW(R1帧)：FGC#xff224400)&#34；x&#34；)(OUT(：COLCOL：ROW(R2帧))&#34；/&#34；)(deFun Display-Screen(FM)(Dolist(Frame(Frame FM))(if(eq Frame(Active FM))(ctl(：bgc#x22224400)(：fgc#xffffff00))(ctl(：bgc#x1111100)(：fgc#xbbbbb00)(渲染应用程序FM帧)(渲染装饰FM帧)。</p><p>(去趣句柄-事件(FM事件)(Flet((Reset()(ctl(：bgc#x22222200))(update-console-Dimension)(清除终端)(cond((keyp event#\q：C)(cl-user：：Quit))((keyp event#\R：C)(Reset))((keyp event#\N：C)(Alexandria：IF-let。((CUR(活动FM)(let*((fms(帧FM))(POS(位置FMS))(NEW(1+POS)(IF(=NEW(长度FMS))(SETF(活动FM)NIL)(SETF(活动FM)(ELT FMS NEW)(SETF(活动FM)(FIRST(FRAMES FM)((KEYIP EVENT#\U。：c)(Ignore-Errors(用户操作)((Keyp Event#\E：C)(Error&#34；bam&#34；)(deun start-display()(LOOP(with-Simple-Restart(再一次&#34；再次启动显示。&#34；))(忽略错误(swank：create-server))(Handler-case(with-console(：IOS*Terminal-io*))</p><p>..</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://turtleware.eu/posts/Charming-CLIM-tutorial-part-2--Rethinking-The-Output.html">https://turtleware.eu/posts/Charming-CLIM-tutorial-part-2--Rethinking-The-Output.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/lisp/">#lisp</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/terminal/">#terminal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/缓冲区/">#缓冲区</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>