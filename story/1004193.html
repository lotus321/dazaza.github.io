<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析器组合器中有什么？(2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">解析器组合器中有什么？(2016)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-29 10:51:54</div><div class="page_narrow text-break page_content"><p>作为我在Haskell取得进展的持续努力的一部分(这是我2016年的目标之一！)，我在edX上关注Erik Meijer的函数式编程MOOC。</p><p>第一堂课是非常基础的东西，我很快就学完了。第7课是关于函数解析器和M*(可怕的)。这就是我第一次遇到困难的地方，我想这会是一篇有趣的文章。我以前已经在Haskell中使用过解析器组合器(主要是Parsec和Attoparsec)，但从未真正理解它们是如何工作的，或者至少不足以自己实现一个解析器组合器。下面是我对这个问题的看法。不要期待真正先进的东西！这只是对基本概念的介绍，我们可以在此基础上构建更复杂、更有用的工具。特别是，我不会谈论：</p><p>编写您自己的解析器组合器库的一个有趣的事实是，您将在这个过程中学习(或巩固)其他知识，比如：函数器、应用程序，当然还有Monad，更一般的是，如何在Haskell中设计DSL。我已经知道这个概念了(至少，我是这么想的，…)。，但是从高级抽象中知道某件事是什么，与知道如何在具体类型(如解析器)上实现它不是一回事！</p><p>我们可以将解析器视为消耗某些输入的东西，并输出所消耗内容的结构化表示形式。为简单起见，我们将只使用字符串(Haskell类型字符串)。所以这大概是这样的：</p><p>这里，a表示从字符流(字符串)构建的内容的类型。这可以是语法树、数字列表或其他任何内容。例如，能够识别像&#34；[1，2，3，4]&#34；这样的字符串的解析器的类型可以是：parser[Int](扩展为string-&gt；[Int])，这意味着它接受一个字符串并输出一个整数列表。</p><p>考虑到第一点，我们可以返回a而不是a(在失败的情况下不会产生任何结果)。请注意，我们还可以使用更丰富的类型，如任一种类型来处理解析错误。对于第二点，我们可以返回一个由a和字符串组成的元组，它表示未被解析器使用的字符串部分。然后，该类型将变为：</p><p>举一个失败的解析器的例子，如果您使用我们前面的能够处理整数列表的解析器，如果您给它字符串&#34；[1，2&#34；；，它将失败，并且不返回任何内容。</p><p>类似地，如果我们向解析器提供&#34；[1，2，3，4]toto&#34；，它将消耗字符串中表示整数列表的部分，而留下&#34；toto&#34；作为剩余的输入。因此，结果将是：Just([1，2，3，4]，&#34；toto&#34；)。</p><p>--此解析器始终成功并返回作为输入给定的值--(保持输入字符串不变)：：a-&gt；Parser a a=Parser$\s-&gt；Just(a，s)。</p><p>--此解析器返回输入字符串的第一个字符，--空输入时失败：：parser Char=Parser$\s-&gt；case s of[]-&gt；Nothing(c：xs)-&gt；Just(c，xs)。</p><p>基本解析器的行为似乎与预期一致。我们在失败的情况下什么也得不到，并且他们能够部分使用输入。所以一切都很好，但是更复杂的解析器呢？我们希望解析字符串或更复杂的模式。让我们使用基本的解析器尝试从输入中识别字符串：</p><p>：：string-&gt；Parser String&#34；&#34；=return&#34；&#34；(c1：xs1)=Parser$\s-&gt；case runParser oneChar of Nothing-&gt；Nothing Just(c2，REST)-&gt；if c1==c2则case runParser(String Xs1)Nothing of Nothing-&gt；Nothing Just(Match，rest 2)-&gt；Just(c2：Match，REST 2。</p><p>这不是很方便(但很有效)…。因为我们必须一遍又一遍地编写样板来编写解析器。希望我们知道一个著名的结构，它允许在Haskell中进行组合，它叫做Monad(我不会再做关于Monad的教程，所以我假设您已经熟悉了这个概念)。这意味着我们可以通过使我们的解析器类型成为Monad的实例来避免所有的样板。这将允许我们使用DO语法干净地编写我们的解析器！甜!。</p><p>要做到这一点，我们必须使我们的解析器成为：Functor、Applicative和Monad的实例。</p><p>首先，我们的解析器是函数器的一个实例，这意味着我们可以将函数映射到我们的解析结果上：</p><p>Instance functor Parser其中--FMAP：：(a-&gt；b)-&gt；Parser a-&gt；Parser b--1.对输入字符串运行Parser。--2.对解析结果应用函数。FMAP f p=Parser$\s-&gt；case runParser p s of Nothing-&gt；Nothing Just(a，rest)-&gt；Just(f a，rest)</p><p>--解析`String`&#34；42&#34；然后使用`read`：：parser Int=(FMAP Read$String&#34；42&#34；)parse42&#34；42将其转换为`Int`！&#34；</p><p>其次，我们可以使我们的解析器成为Applicative的实例。这部分对我来说并不明显。我找到的所有示例都是关于简单类型的实例，比如可能，但我发现解析器非常不同。但是多亏了类型和一些用例(您可以在下面找到)，我想到了下面的实现(希望它是正确的…)。：</p><p>实例应用解析器，其中--PURE：：A-&gt；Parser a--在解析器内包装一个值，保持输入不变。Pure a=Parser$\s-&gt；Just(a，s)--(&lt；*&gt；)：：Parser(a-&gt；b)-&gt；Parser a-&gt；Parser b--1.在输入上运行第一个解析器(生成函数(a-&gt；b)。--2.对第一个解析器留下的剩余输入运行第二个解析器。--3.对第二个解析器的结果应用函数(a-&gt；b)。p1&lt；*&gt；p2=解析器$\s-&gt；case runParser p1 s of Nothing-&gt；Nothing Just(f，rest)-&gt；case runParser p2 Rest of Nothing-&gt；Nothing Just(a，rest 2)-&gt；Just(f a，rest 2)。</p><p>前一个实例的用处可能并不明显，但它允许我们在解析器领域内提升一些功能。例如，如果我们想要获取几个解析器的结果，然后将它们的结果分组到一个元组中，我们可以使用Applicative来实现：</p><p>这是我们将用来将原始解析结构转换为我们自己的类型(例如：AST)的构造。</p><p>数据AST=Foo String|Bar String|Pair Char Char派生(显示)，parseBar，parsePair：：parser AST=Foo&lt；$&gt；String&#34；foo&#34；=Bar&lt；$&gt；String&#34；bar&#34；=Pair&lt；$&gt；oneChar&lt；*&gt；oneChar。</p><p>最后但并非最不重要的一点是，我们的解析器是Monad。这意味着它必须实现：&gt；&gt；=，&gt；&gt；&gt；，返回和失败：</p><p>实例单项解析器WHERE--(&gt；&gt；=)：：Parser a-&gt；(a-&gt；Parser b)-&gt；Parser b--1.在输入时运行第一个解析器。--2.将解析结果反馈给`f`。--3.在剩余部分运行第二个解析器(`f`的结果)--input(由第一个解析器留下)p&gt；=f=Parser$\s-&gt；case runParser p s of Nothing-&gt；Nothing Just(a，rest)-&gt；runParser(F A)rest--(&gt；&gt；)：parser a--&gt；Parser b-&gt；Parser b--1.运行。--2.对剩余输入(第一个解析器留下)运行第二个解析器--我们忽略第一个解析器的结果。p1&gt；&gt；p2=解析器$\s-&gt；case runParser p1s of Nothing-&gt；Nothing Just(_，REST)-&gt；runParser p2 rest--return：：A-&gt；Parser a return=纯--FAIL：：String-&gt；Parser a Fail_=Parser(Const Nothing)</p><p>多亏了这个定义，我们可以使用DO语法糖，这将简化更复杂的解析器的实现。让我们看看我们能做些什么。</p><p>--从输入解析特定的`Char`：：Char-&gt；Parser Char c=do C1&lt；-oneChar如果c==C1，则返回C1否则失败。</p><p>--从输入解析特定模式：：string-&gt；Parser string[]=return[](c：xs)=do c1&lt；-char c rest&lt；-string&#39；xs return(c1：rest)。</p><p>do表示法使组合解析器变得非常容易！我们现在有了一些基本的构建块，我们可以使用它们来实现更多的解析组合符：选项、许多、选项等等。但是我将把它留作练习。</p><p>此外，实现错误报告机制以及位置跟踪(定位输入中的错误)会很有趣，但我将把它留给另一个博客帖子(或者作为读者的练习！)。</p><p>实现(非常)基本的解析组合器使我更好地理解了Parsec或Attoparsec等库的基础，并实现了Applicative和Monad等类型类的不那么微不足道的实例。虽然很基本，但我认为这是更熟悉Haskell的类似DSL的功能，并感受该语言在特定领域建模方面提供的强大功能的好方法。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://remusao.github.io/posts/whats-in-a-parser-combinator.html">https://remusao.github.io/posts/whats-in-a-parser-combinator.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/组合/">#组合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parser/">#parser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>