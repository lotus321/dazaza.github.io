<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>你能写一个矢量化的归约运算吗？(2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">你能写一个矢量化的归约运算吗？(2016)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-09 16:57:03</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/5/91156a72166fb056977258ede7c72f7e.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>为了向客户证明他们的复数索引集合从结构数组(包括实数部分和虚数部分)更改为数组结构，我创建了他们的热点代码的简化版本，用于计算差的平方和。(=。在其最基本的情况下，这是一个for循环，它采用两个大小相等的复数值向量，计算相应实值的差值和相应虚值的差值，将两个计算的差值平方，将两个差值相加，然后将和加到运行总和中。</p><p>为了说明我试图阐明的观点，我使用客户端原始的复杂结构数组实现了for循环计算，然后添加了另一个版本的计算循环，但是使用的结构包含实数组和虚数组。在这两种情况下，我都在C++代码中使用双精度浮点值。正如预期的那样，由于更好的数据布局，我的数组方法的结构明显好于原始的数据结构。为了更进一步，我编译了我的示例以使用AVX矢量化。这些结果为数据结构的改变提供了更好的论据。</p><p>为了激励自己，我决定在源代码中使用AVX向量内部函数编写这两个测试的另一个版本。我意识到计算的核心相当简单：将数据复制到向量寄存器，复制和置换向量寄存器内容，进行几次乘法和一些加法。我知道所有这些操作都是受支持的，所以我转到在线Intel Intrinsics Guide页面，找出到底需要哪些内部功能。选择我的目标系统支持的技术并选择操作类别，我很快就确定了我需要的所有内部语句的作用域。也就是说，直到我意识到我需要一个减法操作才能在最终的向量寄存器中进行单独的求和的最终相加。</p><p>还有什么比这更简单的呢？我的意思是，归约是并行计算中的基本操作，对吗？OpenMP和英特尔线程构建块都有内置的约简操作，“并发艺术”第6章的一半介绍了如何实现并行求和(约简)。听从了后者的建议(我是一个懒惰的程序员)，我去搜索了一个在线示例代码。我猜想某个地方的某个人一定已经编写了向量归约的内在版本，但在用谷歌搜索了20分钟后，我还没有找到任何接近的东西。因此，我又翻阅了“英特尔内部指南”，自己动手写了一本。</p><p>为了防止由于长时间的期待而给读者带来压力，下面是我设计的算法的独立实现，该算法在AVX向量寄存器内减少4个双精度值，并打印出最终答案(只是为了检查结果并显示它是正确的)。在该算法中有四个步骤，将获取ymm0向量变量中的值，将四个双精度值相加，然后将该和保留在最终向量变量(Ymm4)的四个元素中的每一个元素中。在完整的代码之后，我将更详细地描述使用的四个算法步骤和内部结构中的每一个。</p><p>#include&lt；iostream&gt；//获取AVX内部函数#include&lt；immintrin.h&gt；double outinData[4]={2.0，3.0f，2.0f，5.0f}；Double outdata[4]={0.0，0.0，0.0，0.0}；__m256d ymm0，ymm1，ymm2，ymm3，ymm4；int main(){*ymm0=_mm256。*ymm2=_mm256_add_pd(ymm0，ymm1)；*ymm3=__mm256_permute2f128_pd(ymm2，ymm2，0x01)；*ymm4=__mm256_add_pd(ymm2，ymm3)；*_mm256_storeu_pd(outdata，ymm4)；*STD。&lt；&#34；&lt；&lt；outdata[1]&lt；&lt；&#34；&lt；&lt；&outdata[2]&lt；&lt；&#34；&#34；&lt；&lt；outdata[3]&lt；&lt；std：：Endl；}。</p><p>为了帮助描述，因为我自己是一个视觉学习者，所以我在归约算法的每个阶段对矢量变量的内容进行了说明，这将有助于显示每个AVX内在函数的操作。只是为了做一些不同和有趣的事情，我将使用排骨多米诺骨牌来表示AVX向量寄存器中的四个值。出于我的目的，我将忽略点的配置，点的颜色，瓷砖的名称，我希望您也可以。只需计算每个瓷砖上的斑点数量，即可确定矢量的每个部分内的值。(我的代码使用双精度浮点值，而说明性多米诺骨牌具有整数个点。)。</p><p>在示例代码中，我已经将要执行约简的数据加载到ymm0变量中。(虽然我已经根据处理器中的向量寄存器命名了这些变量，但没有隐含的o</p><p>简化的第一条指令是复制ymm0寄存器内的数据，置换向量元素的顺序，并将该置换存储在ymm1寄存器中。</p><p>第一个参数是数据源ymm0，第二个参数是一个整数位掩码，用于控制源中元素的排列方式。最低有效位(索引[0])指定向量中最低有效元素的源(位63：0)，掩码中的第二个最低有效位(索引[1])指定向量中的下一个64位元素(位127：64)，依此类推，用于上面两个向量元素。最低有效位中的‘0’仅将最低有效64位的当前值复制到目的地；该位置中的‘1’将第二最低有效元素(位127：64)复制到最低有效目的地向量元素。对于掩码中的第二个最低有效位，相反的值将对第二个目的向量元素执行相同的操作。也就是说，‘1’将复制相同的值，而‘0’将复制最低有效向量元素。此指令与128位通道一起工作，因此矢量寄存器元素的上半部分将以相同的方式进行排列(只需将128加到所有位索引上)。</p><p>(现在，如果您理解了我对这个内在机制操作的略微曲折的解释，那么您就比我更善于阅读。对于我们其余的人来说，下面有一张图片说明了ymm1中将存储的内容，它将至少比复杂的单词少1000个。无论采用哪种方式，我都建议您参考Intel Intrinsics Guide，以获得我正在使用的所有Intrinsics的官方说明、参数和操作。)。</p><p>对于我的约简操作，我使用的位掩码是‘0101’(或十六进制的0x05)。这将交换值在较低的向量元素对中的位置，并交换值在较高的向量元素对中的位置。将下面的图片与上图中的图片进行比较，以确切地了解这些元素是如何在ymm1寄存器中结束的。</p><p>这是一条非常基本的指令，采用两个源寄存器(ymm0、ymm1)，添加相应的元素，并将和存储到目标寄存器的相应元素中。下面我用两个示例源寄存器以及将存储在ymm2目标中的内容来说明这一点。</p><p>在第二次操作之后，还原已经完成了一半。从图中我们可以看到，原始向量寄存器的两个上半部分和两个下半部分的总和已经相加，并分别复制到两个上半部分和两个下半部分中。</p><p>要完成缩减，我只需要执行两个类似的操作：置换和添加。然而，排列将需要复制128位的矢量数据。这是通过以下内在机制实现的：</p><p>如果您在《英特尔内部指南》中查找此说明，您会注意到前两个参数(可能)是两个不同的矢量源寄存器。我在这里使用了相同的寄存器，因为我实际上只需要置换(或复制)来自单个源的数据。与我之前使用的置换指令一样，最后一个参数是一个位掩码，用于控制复制到目标寄存器的内容。</p><p>在我使用的文档中，位掩码使用8位，低位半字节表示复制到目标的低位128位的内容，高位半字节控制复制到256位寄存器的高位128位的值。对于两个输入源，从何处复制128位寄存器内容有4种可能：第一源(‘0’)的下半部分(位127：0)、第一源(‘1’)的上半部分(位255：128)、第二源的下半部分(‘2’)和第二源的上半部分(‘3’)。</p><p>在研究Intrinsics Guide中的这一内在特性时，我发现一件令人困惑的事情是，虽然位掩码一次使用4位，但只有2位用于确定要复制四个数据源中的哪一个。指定位掩码时，二进制值“0001”将被视为与“1101”相同，因为最高的两个位似乎被抛出。网站上显示的操作码暗示情况就是这样。(事实并非如此。如果您很好奇，我建议您尝试一下上面的程序和第二个内在排列中的位掩码。)。就我的目的而言，我不需要担心这一点，因为我只是将同一源寄存器ymm2的高128位和低128位部分交换到目标寄存器。</p><p>下面的示例说明了在执行此置换内在属性之后，源寄存器ymm2和目标寄存器ymm3的内容。(您看到上面指令中的位掩码‘0x21’会产生相同的结果吗？)。</p><p>最后，现在一切就绪，简单的向量相加YMM2和YMM3寄存器将完成原始向量寄存器中的值的减去。</p><p>这就是对AVX 256位矢量寄存器中的四个双精度元素进行求和缩减的全部内容。完整代码示例中的最后几条指令从最终向量寄存器复制四个结果值，然后将它们打印出来以确认正确答案。</p><p>这个算法可以在不同的数据类型和不同的矢量技术下实现吗？我没有太详细地研究一般问题，但是如果有一组合适的置换内部函数可用，应该可以为不同大小和类型的数据构建类似的约简算法。</p><p>现在您可能想知道，我在研究内部函数、解码操作细节以及尝试参数和位掩码的不同组合上所付出的努力是否值得，直到我找到了正确的公式。遗憾的是，并不是这样。将我的手工编码的差值平方和的矢量化(包括四步缩减)与编译器生成的简单for循环代码版本的矢量化进行比较，我的手工编码的矢量化只有很小的提高性能的余地。这告诉我，某个从事编译器工作的人可能已经弄清楚了与我上面描述的内容类似的东西。这里的课程只是加强了让编译器找到源代码并将其转换为矢量化代码的格言，程序员可以根据需要给出提示或进行少量重写。</p><p>总而言之，整个演习确实有一线希望。我在想，有了这份出版物，它可能是网络上第一个(也是唯一一个)在谷歌上搜索“矢量化缩减”就会得到一个切实的算法的地方。不过，我怀疑没有人会敲开我的门来拿这个。也许我应该继续安装微波炉，定制厨房快递，移动那些冰箱和彩色电视。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://software.intel.com/content/www/us/en/develop/blogs/can-you-write-a-vectorized-reduction-operation.html">https://software.intel.com/content/www/us/en/develop/blogs/can-you-write-a-vectorized-reduction-operation.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/归约/">#归约</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>