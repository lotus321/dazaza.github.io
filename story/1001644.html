<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C++中的立体设计原则：开闭原则</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>C++中的立体设计原则：开闭原则</h1><div class="row"><div class="col-lg-8 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time">2020-05-11 13:16:31</div><p>这是关于Solid As Rock设计原则的五篇系列文章的第二部分。可靠的设计原则结合在一起，使得程序员可以很容易地制作出易于维护、重用和扩展的软件。开闭原则(OCP)是本系列的第二个原则，我将在这里用现代C++的极简示例及其优点&通用准则来讨论它。</p><p>顺便说一下，如果您还没有读过我以前关于设计原则的文章，那么下面是快速链接：</p><p>您在本系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用诸如Override、Final、Public(虽然继承)这样的关键字，只是为了使代码紧凑和可使用(在大多数情况下)在单一的标准屏幕大小中。我也更喜欢struct而不是class，因为有时不编写“public：”来节省行，而且还故意遗漏了虚拟析构函数、构造函数、复制构造函数、前缀std：：、删除动态内存。我也认为自己是一个务实的人，希望以尽可能简单的方式传达一个想法，而不是用标准的方式或使用行话。</p><p>如果您是直接在这里跌跌撞撞的，那么我建议您检查一下什么是设计模式？首先，即使它是微不足道的。我相信它会鼓励你在这个话题上进行更多的探索。</p><p>您在本系列文章中遇到的所有代码都是使用C++20编译的(尽管我在大多数情况下使用的是最高可达C++17的现代C++特性)。因此，如果您无法访问最新的编译器，您可以使用https://wandbox.org/，它也预装了Boost库。</p><p>从字面上看，这意味着您应该能够扩展类行为，而无需修改它。这可能对您来说很奇怪&可能会提出一个问题，即如何才能在不修改类的情况下更改类的行为呢？</p><p>但是在面向对象的设计中有很多解决方案，比如动态多态性、静态多态性、模板等等。</p><p>枚举类颜色{红，绿，蓝}；枚举类大小{小，中，大}；结构产品{string m_name；color m_color；size m_size；}；Using Items=Vector&lt；Product*&gt；；#定义所有(C)BEGIN(C)，END(C)struct ProductFilter{Static Items by_COLOR(Items，Const color e_color){Items Result；For(AUTO&AMP；I：Items)IF(I-&&GT。}Static Items by_size(Items Items，Const Size e_Size){Items Result；For(AUTO&amp；I：Items)if(i-&gt；m_size==e_size)result。Push_back(I)；return result；}Static Items by_size_and_color(Items Items，Const Size e_Size，Const color e_color){Items Result；For(AUTO&amp；I：Items)if(i-&&gt;；m_size==e_size&amp。m_color==e_color)result t.push_back(I)；return result；}}；int main(){const Items all{new Product{&#34；Apple&#34；，color：：green，size：：mall}，new Product{&#34；tree&#34；，color：：green，size：：Large}，new Product{&#34；house&#34；，color：：Blue，size：：Large}，}；(自动&amp；p：ProductFilter：：by_color(all，color：：green)cout&lt；&lt；p-&gt；m_name&lt；&lt；&#34；为(AUTO&amp；p：ProductFilter：：by_size_and_color(all，size：：Large，color：green))cout&lt；&lt；p-&gt；m_name&lt；}/*苹果是绿树是绿树是绿&amp；大*/</p><p>所以我们有一系列的产品&我们根据它的一些属性对其进行了过滤。只要需求是固定的，上面的代码就没有错(在软件工程中永远不会出现这种情况)。</p><p>但是可以想象一下这样的情况：您已经将代码发送给了客户端。稍后，需求更改&&需要一些新的过滤器。在这种情况下，您再次需要修改类&amp；add new filter方法。</p><p>这是一个有问题的方法，因为我们有2个属性(即颜色和大小)&amp；需要实现3个功能(即颜色、大小及其组合)，另外一个属性&amp；需要实现8个功能。你知道这是怎么回事了吧。</p><p>您需要再次执行&amp；在现有的已实现代码中&amp；必须修改它，这可能还会破坏代码的其他部分。这不是一个可扩展的解决方案。</p><p>开放-关闭原则规定，您的系统应该对扩展开放，但是对于修改应该关闭。不幸的是，我们在这里做的是修改现有代码，这违反了OCP。</p><p>实现OCP的方法不止一种。在这里，我将演示流行的界面设计或抽象层。下面是我们的可扩展解决方案：</p><p>Template&lt；TypeName T&gt；struct Specification{virtual~Specification()=default；Virtual bool is_subsured(T*Item)const=0；}；struct ColorSpecification：Specification&lt；Product&gt；{color e_color；ColorSpecification(Color E_Color)：E_COLOR(E_Color){}bool is_subsured(Product*Item)const{Return Item-&gt；m_color==e_color；}}。SizeSpecification(Size E_Size)：E_Size(E_Size){}bool is_subsued(Product*Item)const{Return Item-&gt；m_size==e_Size；}；Template&lt；TypeName T&gt；struct filter{Virtual Vector；T*&&gt;Filter(Vector&lt；T*&&gt;Items，Const Specification&lt；T&gt；&amp；spec)=0；Product*&gt；Items，Const Specification&lt；Product&gt；&amp；spec){Vector&lt；Product*&gt；Result；for(auto&amp；p：Items)if(spec.is_ssured(P))result.Push_back(P)；Return Result；}}；//--BetterFilter bf；For(AUTO&amp；x：bf.filter(ALL，色彩规格(COLOR：：GREEN)cout&lt；&lt；X-&gt；m_name&lt；&lt；&#34；为绿色\n&34；；</p><p>如您所见，我们不必修改BetterFilter的Filter方法。它现在可以与各种规格一起使用。</p><p>Template&lt；TypeName T&&gt;；struct&&gt;Specification：Specification&lt；T&gt；&amp；First Const Specification&lt；T&gt；&amp；First Const Specification&lt；T&gt；&amp；Second AndSpecification(Const Specification&lt；T&gt；&amp；First，Const Specification&lt；T&gt；&amp；Second)：First(First)，Second(Second){}bool。}}；Template&lt；TypeName T&gt；AndSpecification&lt；T&gt；Operator&amp；&amp；(Const Specification&lt；T&gt；&amp；First，Const Specification&lt；T&gt；&amp；Second){return{first，Second}；}//--auto GREEN_ITHES=颜色规格{COLOR：：GREEN}；AUTO LARGE_ITHES=尺寸规格{SIZE：：LARGE}；BetterFilter bf；for(auto&amp；x：bf.filter(all，green_Things&amp；&amp；Large_Things))cout&lt；&lt；x-&gt；m_name&lt；&lt；&#34；；//警告：以下内容可以编译，但不起作用//auto spec2=SizeSpecification{size：：Large}&amp；&amp；//ColorSpecification{。</p><p>SizeSpecification{size：：Large}&amp；&amp；ColorSpecification{color：：Blue}将不起作用。有经验的C++眼睛可以很容易地识别其中的原因。虽然临时对象创建在这里是一个提示。如果这样做，可能会得到如下纯虚函数的错误：</p><p>名为Terminate的纯虚方法在没有活动异常的情况下调用终端进程终止，退出代码为：3。</p><p>“当对程序的一次更改导致对相关模块的一系列更改时，该程序就会显示出我们已经将其与‘糟糕’设计联系在一起的不良属性。程序变得脆弱、僵硬、不可预测和不可重用。开放-封闭原则以一种非常直截了当的方式攻击这一点。它说你应该设计永远不变的模块。当需求发生变化时，您可以通过添加新代码来扩展这些模块的行为，而不是通过更改已经可以工作的旧代码。“-Robert Martin。</p><p>这种方法的主要好处是，接口引入了额外的抽象级别，从而实现了松散耦合。接口的实现彼此独立，不需要共享任何代码。</p><p>因此，您可以很容易地应付客户不断变化的要求。在敏捷方法中非常有用。</p><p>开闭原则也适用于插件和中间件架构。在这种情况下，您的基础软件实体就是您的应用程序核心功能。</p><p>在插件的情况下，您有一个基本或核心模块，可以通过公共网关接口插入新特性和新功能。Web浏览器扩展就是一个很好的例子。</p><p>在SRP中，您可以判断代码中的分解和在何处绘制封装边界。在OCP中，您可以判断您将把模块中的哪些内容抽象，并留给模块的使用者来具体，以及您自己要提供哪些具体的功能。</p><p>有许多设计模式可以帮助我们在不更改代码的情况下扩展代码。例如，装饰者模式帮助我们遵循开闭原则。此外，工厂方法、策略模式或观察者模式也可用于设计易于更改的应用程序，只需对现有代码进行最少的更改。</p><p>请记住，课程永远不能完全停课。总会有不可预见的变化需要修改类。然而，如果更改是可以预见的，比如上面看到的过滤器，那么当这些更改请求滚滚而来时，您就有一个完美的机会来应用OCP来为将来做好准备。</p><p>你喜欢吗，☝️？将此类文章直接放入收件箱…。📥</p><div class="text-break sotry_link"><a target="_blank" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/">http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/</a></div><div class="story_tags"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>