<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>了解K近邻(KNN)算法的基本原理</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>了解K近邻(KNN)算法的基本原理</h1><div class="row"><div class="col-lg-8 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time">2020-05-12 22:20:24</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/5/f58df63d920e4b53779113144db2fff4.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><p>K-近邻(KNN)是一种用于回归和分类的有监督学习算法。它的运作可以比作下面的比喻：</p><p>为了进行预测，KNN算法不会像Logistic或线性回归那样从训练数据集计算预测模型。事实上，KNN不需要建立预测模型。因此，对于KNN来说，没有实际的学习阶段。这就是为什么它通常被归类为一种懒惰的学习方法。</p><p>为了能够进行预测，KNN使用数据集来产生结果，而无需任何训练阶段。</p><p>计算机视觉：假设您有一幅图像，您想要找到与该图像相似的图像集，KNN用于查找和预测与输入图像相似的最突出的图像。</p><p>市场营销：假设你在亚马逊上买了一辆婴儿推车，第二天你会收到这家电商公司的电子邮件，说你可能对一套奶嘴感兴趣。亚马逊可以用类似的产品或与你有相同购买习惯的其他客户的产品来瞄准你。</p><p>内容推荐：最有趣的例子可能是Spotify和他们传奇般的推荐引擎。KNN用于许多内容推荐引擎，即使现在有更强大的系统可用，KNN仍然与此相关。</p><p>为了进行预测，KNN算法将使用整个数据集。实际上，对于不属于数据集并且是我们要预测的实际值的观测，该算法将查找与我们的观测最接近的数据集的K个实例。</p><p>然后，对于这K个邻居，算法将使用它们的输出来计算我们要预测的观测值的变量y。</p><p>如果将KNN用于回归问题，将使用K个最接近观测值的y个变量的平均值(或中位数)进行预测。</p><p>如果将KNN用于分类问题，则将使用K个最接近观测值的变量y的模式(出现频率最高的值)进行预测。</p><p>机器学习正迅速向收集数据的地方靠拢--边缘设备。订阅Fritz AI时事通讯，详细了解此过渡以及它如何帮助您扩展业务。</p><p>对于我们想要预测其输出变量y的新观测X：</p><p>计算该观测X与数据集D的其他观测的所有距离。</p><p>使用距离计算函数d将数据集D中的K个观测值保留在接近X的位置。</p><p>从保留的K个观测值中获取y值：1.如果是回归问题，则计算y扣除值的平均值(或中位数)2.如果是分类问题，则计算y扣除值的方法。</p><p>返回步骤3中计算的值，作为KNN为观测X预测的值。</p><p>正如我们刚才在上面的伪代码中看到的，kNN需要一个函数来计算两个观测之间的距离。两点距离越近，它们就越相似，反之亦然。</p><p>我们根据正在处理的数据类型选择距离函数。因此，对于定量数据(例如：体重、工资、尺寸、购物车数量等)。同类型的欧几里德距离是一个很好的候选者。当数据(输入变量)不是同一类型(例如：年龄、性别、长度、体重等)时，出租车几何形状是一种很好的测量方法。</p><p>尝试从头开始对它们进行编码可能是一个很好的算法练习，但是有很多实现可用，并且Python、Swift和Java中的许多库都提供了在内部执行这些计算的ML库。您只需指出您要使用的距离度量即可。</p><p>为了选择适合您的数据的K值，我们使用不同的K值​​多次运行KNN算法，然后我们选择K，它可以减少遇到的错误数量，同时保持算法在接收新数据时进行精确预测的能力。</p><p>当我们将K值降低到1时，我们的预测就变得不那么稳定了。设想一下，我们有K=1，并且我们有一个查询点，周围环绕着几个红点和一个绿点(图1的左上角)，但是绿点是最近的邻居。从逻辑上讲，我们会认为查询点可能是红色的，但是因为K=1，所以KNN算法错误地预测查询点是绿色的。</p><p>相反，当我们增加K的值时，我们的预测由于多数投票或平均投票而变得越来越稳定。因此，我们更有可能做出更精确的预测(直到某个时间点)。另一方面，我们开始看到越来越多的错误。正是在这一点上，我们知道我们把K的值推得太高了。</p><p>在我们在标签中以多数投票(例如，通过选择分类问题中的模式)的情况下，我们通常为K选择奇数(在平局的情况下)。</p><p>根据给定的数据集，K值的选择会有所不同。一般说来，我们使用的邻居越少(K个越少)，我们就越容易受到模型拟合不足的影响。</p><p>此外，我们使用的邻居越多(K值越大)，我们的预测就越可靠。然而，如果我们使用K个邻居，其中K=N，而N是观察的数目，我们可能会过高地拟合我们的模型，使得它不能很好地概括它还没有看到的观察。</p><p>左上图表示2D平面中具有三种可能的标签类型(红色、绿色、蓝色)的点。对于5-NN分类器(K=5)，每个区域之间的边界相当平滑和规则。</p><p>至于N-NN分类器，我们注意到其限制是“混沌的”和不规则的。后者来自这样一个事实，即算法试图将蓝色区域中的所有蓝点和红色区域中的红点都带上-这是一个典型的过拟合情况。</p><p>对于这个例子，我们更喜欢5-NN分类器而不是N-NN分类器。这是因为5-NN分类器比它的对手泛化得更好。</p><p>我们将使用skLearning名为“乳腺癌威斯康星州数据集”的内置数据集，它具有以下功能：</p><p>from sklearn.datets从sklearn.model_election导入sklearn.model_selection导入sklearn.邻居从sklearn.导入KNeighbors分类器导入指标将Numpy作为NP导入matplotlib.pylot作为PLT。</p><p>DataSet=Load_Break_Cancer()print(Dataet.target_names)X=Dataset.data y=Dataset.target occurences_0=np.count_NonZero(y==0)ocurences_1=np.count_NonZero(y==1)plt.figure(figsize=(30，20))plt.grid(color=‘Grey’，linestyle=‘：’，line width=1)plt.bar([‘恶性’，‘良性’]，[发生次数])plt.grid(color=‘Grey’，linestyle=‘：’，line width=1)plt.bar([‘恶性’，‘良性’]，[发生次数。edgecolor=‘Black’)plt.ylabel(‘观测数量’)plt.title(‘目标分布’)xlocs，xlabs=plt.xticks()，用于枚举中的i，v([ococences_0，occuences_1])：plt.text(xlocs[i]，v+10，str(V)，fontSize=20)X_TRINE，X_TEST，Y_TRING，Y_TEST=TRING_TEST_SPLIT(X，Y。RANDOM_STATE=123)PRINT(X_Train.Shape)Print(y_Train.Shape)Print(X_test.Shape)Print(y_test.shape)。</p><p>数据分布不均，但这不是问题，可能与某些事件比其他事件发生的可能性更小有关：</p><p>Accuracy_array=[]，对于范围(1，10)中的k：knn=KNeighbors分类器(n_Neighbors=k)Kn.fit(X_Train，y_Train)y_Forecast=nn.Forecast(X_Test)Accuracy=metrics.Accuracy_Score(y_test，y_pred=y_Forection)Accuracy_Array.append(Accuracy)plt.Figure(Figsize=(30，20))plt.Grid(color=‘Grey’，linestyle=‘。mark=‘o’)plt.xlabel(‘K值’)plt.ylabel(‘Accuracy’)plt.title(‘测试不同K值的准确性’)。</p><p>在图4中，我们注意到最大值为0.965，并且显示为K={5，6，8}。我们可以得出结论，最优的K值是5，因为我们使用的是Minkowski距离，所以你可以尝试迭代其他的K值，但也可以尝试不同的距离函数，比如欧几里得距离。</p><p>KNeighbors分类器(Algorithm=‘auto’，Leaf_size=30，Metric=‘Minkowski’，Metric_params=None，n_Jobs=None，n_Neighbors=1，p=2，Weight=‘Uniform’)。</p><p>KNN是一个很容易理解的算法。这主要是因为它不需要模型就能做出预测。与此相反的是，它必须记住所有的观测结果，才能做出预测。因此，您必须注意输入数据集的大小。</p><p>而且，计算距离以及邻居数目K的方法的选择可能不会立即明显。您可能需要尝试几种组合并调整算法，才能根据您的用例获得满意的结果。</p><p>我试图通过这篇文章传达对KNN算法的简单解释-以下是我们了解到的情况：</p><p>KNN不计算任何预测模型，它是懒惰学习算法家族的一部分。</p><p>KNN通过计算输入观测值与数据集中不同观测值之间的相似度来及时(动态)进行预测</p><p>感谢您阅读这篇文章。如果您有任何问题，请不要犹豫，给我发电子邮件到omarmhaimdat@gmail.com。</p><p>编者按：心跳是一个贡献者驱动的在线出版物和社区，致力于探索移动应用开发和机器学习的新兴交集。我们致力于支持和激励各行各业的开发人员和工程师。</p><p>编辑独立，心跳是由Fritz AI赞助和出版的，Fritz AI是一个帮助开发人员教设备看、听、感和思考的机器学习平台。我们付钱给投稿人，我们不卖广告。</p><p>如果您想投稿，请前往我们的征集投稿人。您还可以注册接收我们的每周时事通讯(深度学习周刊和Fritz AI时事通讯)，在Slake上加入我们，并在Twitter上关注Fritz AI以了解所有最新的移动机器学习。</p><div class="text-break sotry_link"><a target="_blank" href="https://heartbeat.fritz.ai/understand-the-fundamentals-of-the-k-nearest-neighbors-knn-algorithm-533dc0c2f45a">https://heartbeat.fritz.ai/understand-the-fundamentals-of-the-k-nearest-neighbors-knn-algorithm-533dc0c2f45a</a></div><div class="story_tags"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/近邻/">#近邻</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>