<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>x86指令列表</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">x86指令列表</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-02 13:06:55</div><div class="page_narrow text-break page_content"><p>跳转至导航跳转以搜索x86指令集指的是x86兼容微处理器支持的指令集。指令通常是可执行程序的一部分，通常存储为计算机文件并在处理器上执行。</p><p>x86指令集已经扩展了几倍，引入了更广泛的寄存器和数据类型以及新功能。[1]。</p><p>这是Intel的完整8086/8088指令集。这些指令中的大多数(如果不是全部)在32位模式下可用；它们只在32位寄存器(eax、ebx等)上操作。和值，而不是它们的16位(AX、BX等)。对口单位。另请参阅x86汇编语言获取此处理器系列的快速教程。更新后的指令集还根据体系结构(i386、i486、i686)分组，更一般地称为x86 32和x86 64(也称为AMD64)。</p><p>8086/8088数据手册仅记录AAD指令的BASE 10版本(操作码0xD5 0x0A)，但任何其他BASE都可以使用。后来，英特尔的文档也采用了通用形式。NEC V20和V30(可能还有其他NEC V系列CPU)始终使用基数10，并忽略该参数，从而导致许多不兼容。</p><p>(1)AL=端口[IMM]；(2)AL=端口[DX]；(3)AX=端口[IMM]；(4)AX=端口[DX]；</p><p>(JA、JAE、JB、JBE、JC、JE、JG、JGE、JL、JLE、JNA、JNAE、JNB、JNBE、JNC、JNE、JNG、JNGE、JNL、JNLE、JNO、JNP、JNS、JNZ、JO、JP、JPE、JPO、JS、JZ)。</p><p>将数据从一个位置复制到另一个位置，(1)r/m=r；(2)r=r/m；</p><p>(1)PORT[IMM]=AL；(2)PORT[DX]=AL；(3)PORT[IMM]=AX；(4)PORT[DX]=AX；</p><p>r/m=*SP++；POP CS(操作码0x0F)仅在8086/8088上工作。以后的CPU使用0x0F作为较新指令的前缀。</p><p>不是真正的指示。汇编程序将根据目标系统的内存模型将它们转换为RETN或RETF。</p><p>修改堆栈以进入高级语言的过程。接受两个操作数：要在堆栈上分配的存储量和过程的嵌套级别。</p><p>相当于POP DI POP SI POP BP POP AX；此处没有POP SP，它所做的只是添加SP，2(因为AX稍后将被覆盖)POP BX POP DX POP CX POP AX。</p><p>等效于PUSH AX PUSH CX PUSH DX PUSH BX PUSH SP；存储的值是初始SP值PUSH BP PUSH SI PUSH DI。</p><p>等效于IMUL BX、12h IMUL DX、1200h IMUL CX、DX、12h IMUL BX、SI、1200h IMUL DI、字PTR[BX+SI]、12h IMUL SI、字PTR[BP-4]、1200h。</p><p>符号-将EAX扩展为edX，形成四字edX：EAX。由于(I)DIV使用edX：EAX作为其输入，如果在(I)DIV之前没有手动初始化edX(如64/32分区)，则必须在设置EAX之后调用CDQ。</p><p>将ES：[(E)DI]与DS：[(E)SI]进行比较，并根据DF递增或递减(E)DI和(E)SI；可以使用rep作为前缀</p><p>中断返回；D后缀表示32位返回，F后缀表示不生成尾部代码(即LEFT指令)。</p><p>EAX=*ES：EDI±±；(±±取决于DF，ES不能被覆盖)；可以以rep为前缀。</p><p>将ES：[(E)DI]与EAX和递增或递减(E)DI进行比较，具体取决于DF；可以以rep为前缀。</p><p>(SETA、SETAE、SETB、SETBE、SETC、SETE、SETG、SETGE、SETL、SETLE、SETNA、SETNAE、SETNB、SETNBE、SETNC、SETNE、SETNG、SETNGE、SETNL、SETNLE、SETNO、SETNP、SETNS、SETNZ、SETO、SETP、SETPE、SETPO、SETS、SETZ)。</p><p>*ES：EDI±±=EAX；(±±取决于DF，ES不能被覆盖)；可以以rep为前缀。</p><p>r=r&lt；&lt；24|r&lt；&lt；8&amp；0x00FF0000|r&gt；&gt；8&amp；0x0000FF00|r&gt；&gt；24；仅为32位寄存器定义。通常用于在小端和大端表示之间切换。与16位寄存器配合使用时，在486、[2]586和Bochs/QEMU上产生各种不同的结果。[3]。</p><p>将处理器内部高速缓存中所有修改的高速缓存线写回主存储器，并使内部高速缓存无效。</p><p>将第一个操作数与第二个操作数交换，然后将两个值的和加载到目标操作数中。</p><p>返回有关处理器标识和功能的数据，并将数据返回到EAX、EBX、ECX和EDX寄存器。由EAX寄存器指定的指令功能。[1]这也被添加到后来的80486处理器中。</p><p>将edX：EAX与M64进行比较。如果相等，则设置ZF并将ECX：EBX加载到M64。否则，清除ZF并将m64加载到edX：EAX中。</p><p>返回自处理器联机以来的处理器滴答数(自系统上次开机以来)。</p><p>这是由I 386SL和更高版本引入的，也是在I 486SL和更高版本中推出的。从系统管理模式(SMM)恢复。</p><p>还添加了MMX寄存器和MMX支持说明。它们既可用于整数运算，也可用于浮点运算，见下文。</p><p>(CMOVA、CMOVAE、CMOVB、CMOVBE、CMOVC、CMOVE、CMOVG、CMOVGE、CMOVL、CMOVLE、CMOVNA、CMOVNAE、CMOVNB、CMOVNBE、CMOVNC、CMOVNE、CMOVNG、CMOVNGE、CMOVNL、CMOVNLE、CMOVNO、CMOVNP、CMOVNS、CMOVNE。</p><p>生成无效操作码。此指令用于软件测试，以显式生成无效操作码。此指令的操作码是为此目的保留的。</p><p>有时称为快速系统调用指令，该指令旨在提高操作系统调用的性能。请注意，在奔腾Pro上，CPUID指令错误地将这些说明报告为可用。</p><p>处理器提示，以确保在SFENCE调用之前发生的所有存储操作全局可见。</p><p>使包含用来自处理器缓存层次结构的所有级别的源操作数指定的线性地址的缓存线无效。</p><p>对在MFENCE指令之前发出的所有加载和存储指令执行序列化操作。</p><p>向处理器提供以下代码是旋转循环的提示，以实现可缓存性。</p><p>设置要由硬件监控的线性地址范围并激活监视器。</p><p>处理器提示停止指令执行并进入依赖于实现的优化状态，直到发生一类事件。</p><p>使用CRC-32C(Castagnoli)多项式0x11EDC6F41(范式0x1EDC6F41)计算CRC值。这是iSCSI中使用的多项式。与以太网中使用的更流行的奇偶校验相比，它的奇偶校验是偶数，因此它可以用奇数个改变的比特来检测任何错误。</p><p>使RAX中指定的虚拟页和ECX中指定的ASID的TLB映射无效。</p><p>从RAX寄存器中的物理地址指定的VMCB加载处理器状态的子集。</p><p>将current-vmcs指针存储到指定的内存地址。此指令的操作数始终为64位，并且始终位于内存中。</p><p>AMD在其Piledriver[7]系列处理器中引入了TBM和BMI1；后来AMD Jaguar和基于禅宗的处理器不支持TBM。[8]没有英特尔处理器(截至2020年)支持TBM。</p><p>将目标寄存器的高半部分乘以源寄存器的低半部分。</p><p>将目标寄存器的低半部分乘以源寄存器的高半部分。</p><p>将两个无符号整数与进位相加，从进位标志读取进位，并在必要时将其设置在那里。不影响进位以外的其他标志。</p><p>将两个无符号整数与进位相加，从溢出标志读取进位，并在必要时将其设置在那里。不影响溢出以外的其他标志。</p><p>MMX指令在64位宽的MM寄存器上操作。它们与FPU寄存器共享。</p><p>以下MMX指令是使用SSE添加的。它们也可以在Athlon上以MMX+的名称购买。</p><p>FEMMS、PAVGUSB、PF2ID、PFACC、PFADD、PFCMPEQ、PFCMPGE、PFCMPGT、PFMAX、PFMIN、PFMUL、PFRCP、PFRCPIT1、PFRCPIT2、PFRSQIT1、PFRSQRT、PFSUB、PFSUBR、PI2FD、PMULHRW、PREFETCH、PREFETCHW。</p><p>提取压缩的单精度浮点4位符号掩码。寄存器的高位用零填充。</p><p>浮点单位运算ANDPS、ANDNPS、ORPS和XORPS产生与SSE2整数(pAND、PANDN、POR、PXOR)和双一(ANDPD、ANDNPD、ORPD、XORPD)相同的结果，但当应用错误类型的值时，可能会导致域更改的额外延迟。[11]。</p><p>CMPSD和MOVSD与字符串指令助记符CMPSD(CMPS)和MOVSD(MOVS)同名；但是，前者指的是标量双精度浮点，而后者指的是双字串。</p><p>SSE2允许在SSE寄存器上执行MMX指令，一次处理两倍的数据量。</p><p>提取指定的字并将其移至REG，设置位15-0并将其余位清零。</p><p>计算压缩的无符号字节整数的绝对差；然后将8个低差和8个高差分别求和，以产生两个无符号字整数结果</p><p>以下指令只能在SSE寄存器上使用，因为它们本质上不适用于MMX寄存器。</p><p>在指定的目标元素处插入选定的单精度浮点值，并将目标元素置零。</p><p>在指定偏移量处提取一个单精度浮点值并存储结果(如果适用，则为零扩展)。</p><p>将相邻的4字节整数组的绝对8位整数差与起始偏移量相加。</p><p>如果AND结果全为0，则设置ZF，如果AND NOT RESULT全为0，则设置CF。</p><p>用饱和度将2×4压缩有符号双字整数转换为8个压缩无符号字整数。</p><p>SSE5是AMD提议的SSE扩展。该捆绑包不包括全套英特尔SSE4指令，使其成为SSE4的竞争对手，而不是后继者。AMD选择不按照最初的建议实现SSE5，但是引入了派生的SSE扩展。</p><p>将内存中的四个半精度浮点值或XMM寄存器的下半部分转换为XMM寄存器中的四个单精度浮点值</p><p>将内存或XMM寄存器(YMM寄存器的下半部分)中的八个半精度浮点值转换为YMM寄存器中的八个单精度浮点值。</p><p>将XMM寄存器中的四个单精度浮点值转换为内存中的半精度浮点值，或将XMM寄存器的下半部分转换为半精度浮点值。</p><p>将YMM寄存器中的八个单精度浮点值转换为内存或XMM寄存器中的半精度浮点值。</p><p>自2014年起，AMD处理器(从Piledriver体系结构开始)和英特尔(从Haswell处理器和Broadwell处理器开始)都支持。</p><p>从推土机架构开始，在AMD处理器中受支持。截至2017年，不受任何英特尔芯片支持。</p><p>将32位、64位或128位内存操作数复制到XMM或YMM矢量寄存器的所有元素。</p><p>将256位YMM寄存器的下半部分或上半部分替换为128位源操作数的值。目的地的另一半保持不变。</p><p>提取256位YMM寄存器的下半部分或上半部分，并将值复制到128位目标操作数。</p><p>有条件地将任意数量的元素从SIMD向量内存操作数读入目标寄存器，保留剩余的向量元素不读，并将目标寄存器中的相应元素设置为零。或者，有条件地将任意数量的元素从SIMD向量寄存器操作数写入向量内存操作数，而保持内存操作数的其余元素不变。在AMD Jaguar处理器体系结构上，当掩码为零时，此带有内存源操作数的指令占用300多个时钟周期，在这种情况下，指令不应执行任何操作。这似乎是一个设计缺陷。[12]。</p><p>排列在车道内。混洗一个输入操作数的32位或64位向量元素。这些指令是通道内256位指令，这意味着它们通过两个单独的128位混洗对所有256位进行操作，因此它们不能在128位通道上混洗。[13]。</p><p>将两个256位源操作数的四个128位向量元素置乱为256位目标操作数，并使用立即常数作为选择符。</p><p>将所有YMM寄存器设置为零，并将其标记为未使用。在128位使用和256位使用之间切换时使用。</p><p>将所有YMM寄存器的上半部分设置为零。在128位使用和256位使用之间切换时使用。</p><p>将32位或64位寄存器操作数复制到XMM或YMM矢量寄存器的所有元素。这些是AVX1中相同指令的寄存器版本。虽然没有128位版本，但是使用VINSERTF128就可以达到同样的效果。</p><p>将8、16、32或64位整数寄存器或内存操作数复制到XMM或YMM矢量寄存器的所有元素。</p><p>将256位YMM寄存器的下半部分或上半部分替换为128位源操作数的值。目的地的另一半保持不变。</p><p>提取256位YMM寄存器的下半部分或上半部分，并将值复制到128位目标操作数。</p><p>使用32位或64位索引和小数位数收集单精度或双精度浮点值。</p><p>有条件地将任意数量的元素从SIMD向量内存操作数读入目标寄存器，保留剩余的向量元素不读，并将目标寄存器中的相应元素设置为零。或者，有条件地将任意数量的元素从SIMD向量寄存器操作数写入向量内存操作数，而保持内存操作数的其余元素不变。</p><p>使用寄存器或内存操作数作为选择器，将一个256位源操作数的八个32位向量元素置乱为256位目标操作数。</p><p>使用寄存器或内存操作数作为选择器，将一个256位源操作数的四个64位向量元素置乱为256位目标操作数。</p><p>将两个256位源操作数的四个128位向量元素混洗(其中两个)为256位目标操作数，并使用立即常数作为选择符。</p><p>左转符合逻辑。允许可变移位，其中每个元素根据压缩输入移位。</p><p>右转符合逻辑。允许可变移位，其中每个元素根据压缩输入移位。</p><p>算术右移。允许可变移位，其中每个元素根据压缩输入移位。</p><p>将四字或双字向下转换为双字、字或字节；不饱和、饱和或饱和无符号。与SSE4.1中的符号/零扩展指令相反。</p><p>将带截断或不带截断的压缩单精度或双精度浮点转换为压缩的无符号双字整数。</p><p>使用或不使用截断、标量单精度或双精度浮点数转换为无符号双字整数。</p><p>x86CPU包含未记录的指令，这些指令在芯片上实现，但没有在一些官方文件中列出。它们可以在互联网上的各种资源中找到，比如Ralf Brown的中断列表和sandpile.org。</p><p>根据进位标志的值设置AL(SBB、AL和AL的另一种1字节替代)。</p><p>确切用途未知，导致CPU挂起(HCF)。唯一的出路是CPU重置。[14]在老式计算联合会的一篇论坛帖子中，该说明被解释为SAVEALL。它与ICE模式交互。</p><p>欧文·托斯(1998-03-16)。&#34；带16位寄存器的BSWAP&#34；。从原件存档于1999-11-03年。该指令降低了双字寄存器的高位字，而不影响其高16位。</p><p>^Coldwin，Gynvael(2009-12-29)。&#34；BSWAP+66h前缀&#34；。内部(零)扩展较小(16位)寄存器…的值。将BSWAP应用于32位值&#34；00 AH AL&#34；，…。截断到较低的16位，它们是&#34；00；00&#34；。…。Bochs…。bswapreg16的作用类似于bswapreg32…。电动车组…。忽略66h前缀。</p><p>^&#34；RSM-从系统管理模式&#34；继续。存档日期为2012-03-12。CS1维护：BOT：原始URL状态未知(链接)。</p><p>^英特尔64和IA-32架构软件开发人员手册，第4.3节，第#34小节；预取-将数据预取到缓存&#34；</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>