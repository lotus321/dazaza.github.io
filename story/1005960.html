<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Bloom Filters编写全文搜索引擎</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Bloom Filters编写全文搜索引擎</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-10 11:39:18</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/ca9f252e19a5f9fb4108656ede67ecf9.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>几分钟前，我看到了一篇黑客新闻帖子，其中详细介绍了一种将搜索添加到静态站点的方法。您可能知道，将搜索添加到静态站点有点棘手，因为您不能只将查询发送到服务器，然后让服务器处理它并返回结果。如果您想要全文搜索，则必须实现类似于倒排索引的功能。</p><p>倒排索引是一种数据结构，它基本上将每个文档中的每个单词映射到它所在的文档的ID。例如，这样的索引可能类似于{&#34；python&#34；：[1，3，6]，&#34；raspberry&#34；：[3，7，19]}。要查找同时提到“python”和“raspberry”的文档，您可以在索引中查找这些术语，并找到共同的文档ID(在我们的示例中，这只是ID为3的文档)。</p><p>但是，当您有非常长的文档，其中包含不同的单词时，这可能会增长很多。它是一个庞大的数据结构，当您想要实现客户端搜索引擎时，您传输的每个字节都很重要。</p><p>客户端搜索引擎的问题在于，您(显然)必须在客户端执行所有搜索，因此您必须将所有可用的信息传输到客户端。静态站点生成器所做的是在生成站点时生成每个所需的文件，然后使这些文件可供客户端下载。通常，搜索引擎插件仅限于标签和标题，以减少需要传输的信息量。我们怎样才能缩小尺寸呢？轻松使用Bloom Filter！</p><p>Bloom filter是一种非常有趣的数据结构，它可以以固定位数存储元素，并在查询之前告诉您是否看到这些元素。对于我们的用例来说，这听起来很棒，但让我们看看它是否能胜任挑战。</p><p>实现使用Bloom过滤器的全文搜索引擎的简单方法如下：</p><p>为每个文档创建一个筛选器，并将该文档中的所有单词添加到筛选器中。</p><p>将(固定大小)过滤器序列化为某种字符串，并将其发送到客户端。</p><p>当客户端需要搜索时，遍历所有筛选器，查找与所有术语匹配的筛选器，并返回文档名称。</p><p>接下来，我们将使用我最喜欢的语言Python，使用pybloom非常快速地实现这一点。</p><p>首先，让我们阅读本博客中的一些帖子，并创建每个帖子中所有单词的列表：</p><p>从pybloom导入BloomFilter导入os导入重新#阅读我所有的帖子。POST={POST_NAME：OPEN(POST_DIR+POST_NAME)。操作系统中POST_NAME的Read()。listdir(Post_DIR)}#创建{&#34；帖子名称&#34；：&#34；小写单词集&#34；}的字典。Split_Posts={名称：设置(重新。拆分(&#34；\W+&34；，目录。较低的())为名称，帖子中的内容。项目()}。</p><p>在这一点上，我们有一本帖子词典，每个帖子中都有一组规范化的单词。我们可以做更多的事情，比如消除词干、删除常用词(a、the等)，但是我们太天真了，所以我们现在只创建过滤器：</p><p>FILTERS={}表示名称，SPLIT_POSTS中的单词。Items()：Filters[name]=BloomFilter(Capacity=len(Words)，Error_Rate=0.1)for Words in Words：Filters[Name]。添加(单词)。</p><p>您可以在上面看到，每个过滤器的容量正好是每个帖子中的字数，以减少表示它所需的位数。错误率是可以调整的，它是假阳性的概率。概率越低，过滤器越精确，但过滤时间越长。</p><p>现在我们已经准备好了所有的过滤器，我们可以使用任何我们喜欢的序列化方法将它们传输到客户端。让我们编写一个非常简单的搜索算法，根据一些搜索词查找帖子：</p><p>def search(Search_String)：search_term=re。Split(&#34；\W+&#34；，search_string)返回[Name for Name，Filter in Filters。Items()if All(Search_Terms中的术语筛选器中的术语)]。</p><p>search()所做的全部工作就是遍历所有过滤器，并返回与每个给定词语匹配的过滤器。让我们试试看：</p><p>从标题来看，它找到了所有相关帖子，没有任何误报！一点也不差，只干了几分钟！让我们看看过滤器的平均大小是多少：</p><p>对于这样的事情，我觉得每个帖子298个字节是相当合理的大小。如果我们不介意更多的误报，我们可以进一步降低这一点，但是，考虑到上面的搜索结果，我认为对于这样一种天真的方法来说，这是相当好的。作为比较，本段也有298字节长。</p><p>另一种方法是使用单个过滤器，将帖子ID与搜索词(例如“3：Term”)连接起来，然后进行搜索。不幸的是，这会导致过滤器的大小与小的过滤器的大小完全相同，并且计算复杂度更高，因为您必须散列N次(其中N是帖子的数量)，而不是只散列一次。</p><p>使用Bloom过滤器有几个优点，使其适合在静态站点中使用：</p><p>它占用的空间与页数成正比，而不是与字数成正比，因此对于非常长的页面和对于非常短的页面，它占用的空间大致相同(这并不完全正确，因为我们根据字数调整筛选器的大小，但它比倒排索引紧凑得多)。</p><p>搜索复杂度与页面数量成正比，而不是与它们的长度成正比。当您最多只有几千页时，这并不重要，但如果您只有几页长的页，这仍然是很好的。</p><p>由于Bloom过滤器是概率的，这种方法可能会产生误报，但它不会产生漏报，这正是我们想要的搜索引擎(我们不介意搜索结果中有几个不相关的页面，但是如果缺少相关的页面，我们就会介意)。</p><p>你不能根据相关性对页面进行加权，因为你不知道一个单词在一个页面中出现了多少次，你只知道它是否出现。你可能会也可能不会关心这件事。</p><p>您需要在客户端实现Bloom Filter算法。这可能不会比倒排索引搜索算法长多少，但仍然可能稍微复杂一些。</p><p>当然，全文索引仍然很大，可能不适合加载到每个页面视图上，即使在使用这种方法时也是如此，但是这种方法可能适合在静态站点中的专用“搜索”页面中使用。</p><p>实际上，我并不提倡在你的静态站点上使用这种方法，但是，嘿，它让周六晚上的黑客攻击变得有趣了一个小时。现在，我们该出去喝一杯了。如果你在塞萨洛尼基，想要加入我，给我发一封电子邮件，或者让我上推特。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.stavros.io/posts/bloom-filter-search-engine/">https://www.stavros.io/posts/bloom-filter-search-engine/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/bloom/">#bloom</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/full/">#full</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/过滤器/">#过滤器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>