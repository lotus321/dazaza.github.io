<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>几行代码中的Linux容器</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>几行代码中的Linux容器</h1><div class="row"><div class="col-lg-8 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time">2020-05-13 19:02:54</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/5/3cd67f8c773c5df13d60d9d2e7f8918c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><p>这篇文章的意思是与上一篇KVM文章相对应，但它是关于容器的。我们的想法是通过在我们自己的小型容器运行器中运行Busybox Docker映像来显示容器的确切工作方式。</p><p>与VM不同，容器是一个非常模糊的术语。通常，我们将容器称为独立的代码包及其依赖项，它们可以一起发布，并在某个主机操作系统内的隔离环境中运行。如果它听起来仍然类似于VM，那么让我们深入研究一下，看看容器是如何实现的。</p><p>我们的最终目标是运行一个普通的Busybox Docker映像，但没有docker。Docker使用btrfs作为其映像的文件系统格式。让我们尝试拉取图像并将其解压到一个目录中：</p><p>现在，我们将busybox映像文件系统解压到rootfs文件夹中。当然，我们可以运行./rootfs/bin/sh并获得一个工作的shell，但是如果我们查看那里的进程、文件或网络接口的列表，我们将看到我们可以访问整个操作系统。</p><p>由于我们希望控制子进程可以看到的内容，因此我们将使用克隆(2)而不是分叉(2)。Clone的功能大致相同，但允许您传递标志，定义您想要共享的资源。</p><p>在我们的实验中，我们将尝试隔离进程、IPC、网络和文件系统，因此我们开始：</p><p>静态字符CHILD_STACK[1024*1024]；INT CHILD_MAIN(void*arg){printf(&#34；Hello from Child！PID=%d\n&#34；，getPID()；return 0；}int main(int argc，char*argv[]){int flag=CLONE_NENS|CLONE_NEWUTS|CLONE_NEWPID|CLONE_NEWIPC|CLONE_NENet；INT PID=CLONE(CHILD_Main，CHILD_STACK+sizeof(CHILD_STACK)，FLAGS|SIGCHLD，argv+1)；if(PID&lt；0){fprintf。}waitpid(PID，NULL，0)；返回0；}。</p><p>这给出了一个已经很有趣的结果：子进程PID是1。我们都知道PID 1通常是init，但在本例中，我们看到子进程有自己的独立进程列表，其中它已成为第一个进程。</p><p>为了更容易地熟悉新环境，让我们在子进程中运行一个shell。实际上，让我们运行任意命令，很像docker run：</p><p>现在，使用“/bin/sh”参数运行我们的应用程序将打开一个真正的shell，我们可以在其中键入命令。这表明我们关于孤立的看法是多么错误：</p><p>#ECHO$$1#ps PID TTY时间CMD 5998分/31 00：00：00：00 sudo 5999分/31 00：00：00：00 Main 6001分/31 00：00：00 sh 6004分/31 00：00：00：00 ps。</p><p>正如我们所看到的，shell进程本身的PID为1，但实际上可以从主机操作系统查看和访问所有其他进程。原因是进程列表是从procfs读取的，它仍然是继承的。</p><p>现在，运行shell会中断ps、mount和其他命令，因为没有挂载procfs。还是比泄露父母的通行证要好。</p><p>在过去，chroot对于大多数用例来说是一个“足够好”的隔离，但是在这里，我们改用PIVOT_ROOT。此系统调用将现有的rootfs移到某个子目录中，并使另一个目录成为新的根目录：</p><p>int Child_main(void*arg){/*unmount procfs*/umount2(&#34；/proc&#34；，mnt_disach)；/*透视根*/mount(&#34；./rootfs&#34；，&#34；./rootfs&#34；，&#34；；bind&#34；，MS_bind|MS_REC，&#34；)；mkdir(&#34；。./rootfs&#34；，&#34；./rootfs/oldrootfs&#34；)；chdir(&#34；/&#34；)；umount2(&#34；/oldrootfs&#34；，mnt_disach)；rmdir(&#34；/oldrootfs&#34；)；/*重新挂载procfs*/mount(&#34；proc&#34；，&#34；/proc。/*运行进程*/char**argv=(char**)arg；execvp(argv[0]，argv)；返回0；}。</p><p>将tmpfs挂载到/tmp中，将sysfs挂载到/sys中并创建一个有效的/dev文件系统是有意义的，但为了简短起见，我将跳过它。</p><p>不管怎么说，现在我们只看到busybox图像rootfs中的文件，就好像我们对其进行了chroot：</p><p>/#lsbin dev etc home proc root sys tmp usr var/#mount/dev/sda2 on/type ext4(rw，relatime，data=order)proc on/proc type proc(rw，relatime)/#psPID用户时间命令1 root 0：00/bin/sh 4 root 0：00 ps/#ps axPID用户时间命令1 root 0：00/bin/sh 5 root 0：00 ps ax。</p><p>在这一点上，它看起来或多或少是孤立的，也许太孤立了-我们无法ping通任何东西，网络似乎根本无法工作。</p><p>创建新的网络命名空间只是个开始。我们需要为其分配网络接口，并对其进行设置以执行正确的数据包转发。</p><p>如果您没有br0接口，让我们手动创建(brctl是Ubuntu上bridge-utils包的一部分)：</p><p>brctl addbr br0ip addr add dev br0 172.16.0.100/24ip链路集br0 upsudo iptables-A FORWARD-I wlp3s0-o br0-j ACCEPTsudo iptables-A ward-o wlp3s0-I br0-j ACCEPTsudo iptables-t nat-A POSTROUTING-s 172.16.0.0/16-j伪装。</p><p>在我的例子中，wlp3s0是我的主要WiFi网络接口，172.16.x.x是容器的网络。</p><p>我们的容器启动器应该做的是创建一对对等接口veth0和veth1，将它们链接到br0，并在容器内设置路由。</p><p>system(&#34；IP link add veth0 type Veth Peer Name veth1&#34；)；system(&#34；IP link set veth0 up&#34；)；system(&#34；brctl add f br0 veth0&#34；)；</p><p>现在，如果我们在容器外壳中运行“ip link”，我们将看到一个环回接口和一些veth1@xxxx接口。但是网络仍然不起作用。让我们在容器中设置唯一的主机名，并配置路由：</p><p>int Child_main(void*arg){.。sethostname(&#34；Example&#34；，7)；System(&#34；IP link set veth1 up&#34；)；char IP_addr_add[4096]；snprintf(IP_addr_add，sizeof(IP_Addr_Add)，&#34；IP addr add 172.16.0.101/24 dev th1&#34；)；system(Ip_Addr_Add)；system(&#34；route add default。execvp(argv[0]，argv)；返回0；}。</p><p>/#IP link1：LO：&lt；loopback&gt；mtu 65536 qdisk noop qlen 1 link/loopback 00：00：00：00：00：0047：veth1@if48：&lt；Broadcast，Multicast，Up，Low_Up，M-Down&gt；MTU 1500 qdisk noqueue qlen 1000链路/以太72：0A：f0：91：d5：11 brd ff：ff/#hostname示例/#ping 1.1.1.1 PING 1.1.1.1(1.1.1.1)：56数据字节1.1.1.1：SEQ=0 ttl=57 time=27.161 ms 64字节from 1.1.1.1：seq=1 ttl=57 time=26.048 ms 64 bytes from 1.1.1.1：seq=2 ttl=57 time from 1.1.1.1：seq=2 ttl=57 time：seq=1 ttl=57 time=26.048 ms64 byte from 1.1.1.1：seq=2 ttl=57 time。</p><p>完整的源代码可以在https://gist.github.com/zserge/4ce3c1ca837b96d58cc5bdcf8befb80e.上找到。如果您发现错误或有什么建议，请在此留言！</p><p>显然，Docker做的远不止这些。但令人惊讶的是，Linux内核拥有这么多方便的API，而且使用它们来实现操作系统级虚拟化非常容易。</p><div class="text-break sotry_link"><a target="_blank" href="https://zserge.com/posts/containers/">https://zserge.com/posts/containers/</a></div><div class="story_tags"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/容器/">#容器</a></button></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>