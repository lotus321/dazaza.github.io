<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Expresso：一种具有多态可扩展行类型的简单表达式语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Expresso：一种具有多态可扩展行类型的简单表达式语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-13 02:52:30</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/4eb575976a3c62d83bd4d0666e2aa807.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>Expresso是一种最小静态类型的函数式编程语言，设计时考虑了嵌入式和/或可扩展性。这种最小语言的可能用例包括配置(如Nix)、数据交换(如JSON)，甚至是自定义外部DSL的起点。</p><p>Expresso是一种函数式语言，因此我们使用lambda术语作为基本的抽象手段。要创建命名函数，我们只需使用let绑定一个lambda即可。我曾想过使用Nix风格的lambda语法，例如x：x作为标识函数，但是许多主流语言，不仅仅是Haskell，都使用箭头来表示lambda术语。箭头也与我们用来表示类型的符号一致。因此，Expresso使用箭头-&gt；来表示lambdas，要绑定的参数在左边，表达式主体在右边，例如x-&gt；x表示标识。</p><p>Expresso记录建立在以行扩展为基本基元的行类型之上。与以连接为基元构建的更高级系统相比，这提供了一个非常简单和易于使用的类型系统。然而，即使在这个简单的系统中，使用差异记录也可以非常容易地对串联进行编码。</p><p>当然，记录可以包含任意类型，并且可以任意嵌套。他们也可以在平等方面进行比较。点运算符(SELECT)用于投影值。</p><p>Expresso REPL键入：Help或：h以获取命令列表从/HOME/Tim/expresso/prereude.xλ&gt；{x=1}.x1λ&gt；{x={y=&#34；foo&#34；}，z=[1，2，3]}.x.y&#34；foo&#34；λ&gt；{x=1，y=True}=={y=True，</p><p>使用选择消除记录。并使用扩展名|进行介绍。例如，记录文字：</p><p>行类型使用缺乏约束来禁止重叠字段名称。例如，以下代码类型错误：</p><p>{x=1，x=2}--不进行类型检查！让{x=&#34；bar&#34；|r}中的r={x=&#34；foo&#34；}--不进行类型检查！</p><p>通过REPL打印出推断的行类型时，会显示缺少的约束，例如：</p><p>λ&gt；：为所有r.(r\x)=&gt；{r}-&gt；{x：int|r}键入r-&gt；{x=1|r}。</p><p>在上面的输出中，REPL报告这个lambda可以接受底层行类型为r的记录，只要r满足它没有字段x的约束。</p><p>文字记录的类型是关闭的，因为字段集是完全已知的：</p><p>但是，通过推断打开的记录类型，我们允许具有冗余字段的记录作为函数的参数：</p><p>λ&gt；设sqmag={x，y}-&gt；x*x+y*yλ&gt；：键入sqmagforall a r。(num a，r\x\y)=&gt；{x：a，y：a|r}-&gt；a。</p><p>打开的记录类型由记录尾部的行类型指示。</p><p>请注意，上面的sqmag函数定义使用了字段双关。我们也可以写成：</p><p>在记录参数上匹配时，有时可能需要提供新名称以将字段的值绑定到，例如：</p><p>λ&gt；让Add={x=r，y=s}{x=u，y=v}-&gt；{x=r+u，y=s+v}。</p><p>我们可以使用限制原语\删除字段。例如，以下内容将进行类型检查：</p><p>记录可以用作一个简单但功能强大的模块系统。例如，设想一个模块&#34；List.x&34；具有对列表的派生操作：</p><p>设Reverse=foldl(xs x-&gt；x：：xs)[]；intercalate=xs xss-&gt；conat(点缀xs xss)；.--Exportsin{Reverse，Intercalate，.}。</p><p>λ&gt；let List=IMPORT&#34；List.x&34；λ&gt；：为所有a.[a]-&gt；[a]-&gt；[a]键入list.intercalateforall a.[a]-&gt；[a]。</p><p>具有多态函数的记录可以作为lambda参数传递，并使用更高级别的多态保持多态。要实现这一点，我们必须为Expresso提供合适的参数类型注释。例如：</p><p>设f=(m：for all a.{Reverse：[a]-&gt；[a]|_})-&gt；{l=m.verse[True，False]，r=m.verse[1，2，3]}</p><p>上面的函数f采用包含多态函数Reverse的模块&#34；m。我们使用单个冒号：后跟我们期望的类型来注释m。注意记录尾部的下划线_。这是一个类型通配符，意味着我们已经指定了一个分部类型签名。此类型通配符允许我们使用此签名传递包含反向函数的任意模块。要查看f的完整类型签名，我们可以使用Expresso REPL：</p><p>λ&gt；：t fforall r.(r\Reverse)=&gt；(for all a.{Reverse：[a]-&gt；[a]|r})-&gt；{l：[bool]，r：[int]}。</p><p>请注意，代表其余模块字段的r是顶级限定符。通配符类型在这里特别有用，因为它允许我们避免为整个函数创建顶级签名和显式命名此行变量。更一般地，类型通配符允许我们不指定类型签名的某些部分。</p><p>当然，函数f现在可以应用于满足类型签名的任何模块：</p><p>要对串联进行编码，我们可以使用扩展记录的函数，并使用简单的函数组合来组合它们：</p><p>设f=(r-&gt；{x=&#34；foo&#34；，y=True|r})&gt；&gt；(r-&gt；{z=&#34；bar&#34；|r})。</p><p>λ&gt；让f={|x=&#34；foo&#34；，y=True|}&gt；&gt；{|z=&#34；BAR&#34；|}λ&gt；f{}{z=&#34；BAR&#34；，x=&#34；FOO&#34；，y=TRUE}。</p><p>{|x=&#34；foo&#34；|}&gt；&gt；{|x：=&#34；bar&#34；|}--类型检查{|x=&#34；foo&#34；|}&lt；&lt；{|x：=&#34；bar&#34；|}--不进行类型检查！</p><p>类型{}是单位类型的一个示例。它只有一个居民，空记录{}：</p><p>记录的DUAL是变体，因为它们使用相同的底层行类型，所以它们也是多态的和可扩展的。变量是通过注入(记录选择的DUAL)引入的，例如：</p><p>λ&&gt;；案例FOO 1，共{foo x-&gt；x，条形{x，y}-&gt；x+y}1。</p><p>上面的case表达式消除了闭合变量，这意味着除foo或Bar以外的任何值及其预期有效负载都将导致类型错误。为了消除开放变量，我们使用类似于扩展的语法：</p><p>λ&&gt;；设f=x-&&gt;；案例x，{foo x-&gt；x，条形{x，y}-&gt；x+y|否则-&gt；42}λ&gt；f(baz{})42。</p><p>在这里，不匹配的变量被传递给lambda(以Altherly作为参数)。条形|后面的表达式通常会忽略变量或将其委托给另一个函数。</p><p>我们经常需要创建封闭的变体类型。例如，我们可能想要创建一个类似于Haskell的“可能a”的结构类型，它只有两个构造函数：Nothing和Just。这可以使用带有类型批注的智能构造函数来完成。在前言中，我们定义了等价的构造函数Just和Nothing，以及可能在此封闭集上的一个文件夹：</p><p>类型可能a=&lt；Just：a，Nothing：{}&gt；；Just：for all A.a-&&gt；可能a=x-&&gt;；Just x；Nothing：Fall a.可能a=Nothing{}；可能=bf m-&gt；案例m{Just a-&gt；f a，Nothing{}-&gt；b}</p><p>注意，我们声明并使用类型同义词可能是a，以避免重复类型&lt；，只是：a，Nothing：{}&gt；。类型同义词可以包含在任何文件的顶部，并且具有全局作用域。</p><p>笔录限制的对偶性是变种嵌入。这允许我们通过利用非重叠字段约束来限制CASE表达式公开的行为。例如，要防止使用上述函数f的Bar替代，我们可以定义一个新函数g，如下所示：</p><p>λ&gt；设g=x-&gt；f(&lt；|栏|&gt；x)λ&gt；：类型gforall r.(r\bar\foo)=&gt；foo：int|r&gt；-&gt；Int；Int。</p><p>λ&gt；设g=x-&gt；案例x，共{Override foo x-&gt；x+1|f}。</p><p>λ&gt；设g=x-&gt；案例x为{foo x-&gt；x+1|&lt；|foo|&gt；&gt；f}λ&gt；：类型为gforall R1 R2。(r1\x\y，r2\Bar\foo)=&gt；&lt；foo：int，bar：{x：int，y：int|r1}|r2&gt；-&gt；Int。</p><p>在内部，消除封闭变量的语法使用空变量类型&lt；&gt；，也称为void。void类型没有居民，但是我们可以使用它来定义一个荒谬的函数：</p><p>荒诞是经典逻辑中Ex FAlso Quodlibet的一个例子(任何东西都可以用矛盾作为前提来证明)。</p><p>{酒吧{}-&gt；2|荒诞}}的{foo{}-&gt；1|x&#39；-&gt；案例x&#39；的案例x</p><p>我们可以使用Expresso作为一种轻量级数据交换格式(即带类型的JSON)。但是，我们如何根据模式验证术语呢？</p><p>简单类型批注&lt；Term&gt；：&lt；type&gt；不足以进行&#34；架构验证&#34；。例如，考虑以下针对允许所有内容的架构验证整数的尝试：</p><p>上面的类型检查失败，因为左侧被推断为最通用的类型(这里是一个具体的int)，而右侧的类型必须较少。</p><p>这方面的一个很好的语法甜头是签名部分，尽管Expresso中的版本与Haskell提议略有不同。我们写(：t)表示id：t-&gt；T，其中所有量词都保存在顶级。我们现在可以使用：</p><p>如果我们的模式中确实有允许任意数据的地方，我们应该使用等式约束来保证不存在部分应用的函数。例如：</p><p>(：forall a.eq a=&gt；{x：&lt；foo：int，Bar：A&gt；}){x=Bar id}。</p><p>λ&gt；(：forall a.eqa=&gt；{x：&lt；foo：int，bar：a&gt；}){x=bar&#34；abc&#34；}{x=bar&#34；abc&#34；}。</p><p>Expresso使用惰性计算，希望在处理大型嵌套记录时可以提高效率。</p><p>图灵等价性是通过单个FIX原语引入的，可以很容易地删除或禁用该原语。FIX对于实现开放的递归记录和动态绑定(如Nix)非常有用。</p><p>λ&&gt;；让r=mkOverridable(Self-&&gt;；{x=#34；foo&34；，y=self.x；；&gt；&#34；bar&34；})λ&gt；r{Override_=；λ；Lambda&&gt;；，x=&#34；foo&34；，y=&#34；foobar&34；}λ&&gt;；覆盖r{|x：=。baz&34；，y=#34；bazbar&#34；}。</p><p>请注意，在实践中，删除FIX和Turing等价性并不能保证终止。在没有递归或修复的情况下，仍有可能编写在宇宙的生命周期内不会终止的指数程序。</p><p>在Haskell程序中，可以将Expresso用作键入的配置文件格式。例如，让我们考虑一个备份程序的假设小配置文件：</p><p>让awsTemplate={Location=&#34；s3://s3-eu-west-1.amazonaws.com/tim-backup&#34；，Include=[]，Exclude=[]}位于{cachePath=Default{}，任务线程=覆盖2，配置文件=[{Name=&#34；Pictures&#34；，Source=&#34；~/Pictures&#34；|awsTemplate}，{Name=&#34；Music&#34；，source=&#34；~/Music&#34；，排除：=[&#34；**/*.m4a&#34；]|awsTemplate}]}。</p><p>请注意，即使是对于这样一个小的示例，我们也已经可以利用可扩展记录的一些抽象功能来避免配置文件中的重复。</p><p>为了从Haskell程序使用此文件，我们可以定义一些相应的标称数据类型：</p><p>数据配置=Config{configCachePath：：Overridable Text，configTaskThread：：Overridable Integer，configProfiles：：[profile]}派生Showdata Overridable a=默认|覆盖派生Showdata配置文件=profile{profileName：：Text，profileLocation：：Text，profileInclude：：[Text]，profileExclude：：[Text]，profileSource：：Text}派生显示</p><p>使用Expresso API，我们可以编写HasValue实例来处理Haskell值的投影和注入：</p><p>导入ExpressoInstance HasValue Config，其中proj v=Config&lt；$&gt；v.：&#34；cachePath&#34；&lt；*&gt；v.：&#34；taskThread&#34；&lt；*&gt；v.：&#34；profile&#34；inj Config{..}=mkRecord[&#34；cachePath&#34；.=inj configCache.。.=inj configProfiles]Instance HasValue a=&gt；HasValue(Overridable A)，其中proj=CHOICE[(&#34；Override&#34；，FMAP Override。项目)，(&#34；默认&#34；，常量$PURE DEFAULT)]inj(Override X)=mkVariant&#34；Override&#34；(Inj X)inj default=mkVariant&34；Default&#34；unitinstance HasValue Profile where proj v=profile&lt；$&gt；v.：&#34；name&#34；&lt；*&gt；v：&#34；location&#。*&gt；v.：&#34；exclude&#34；&lt；*&gt；v.：&#34；source&#34；inj profile{..}=mkRecord[&#34；name&#34；.=inj profileName，&#34；location&#34；.=inj profileLocation，&#34；include&#34；.=inj profileInclude，&#34；exclude&#34；.=inj。</p><p>在加载配置文件之前，我们可能希望根据商定的签名(也称为。模式验证)。Expresso API提供了一个模板Haskell准引号，以便从Haskell内部方便地执行此操作：</p><p>import Expresso.TH.QQschema：：Typesschema=[ExpressoType|{cachePath：&lt；Default：{}，Override：Text&gt；，taskThread：&lt；Default：{}，Override：int&gt；，Profiles：[{name：Text，Location：Text，Include：[Text]，Exclude：[Text]，Exclude：[Text]，source：Text}]}|]。</p><p>因此，我们可以使用以下代码加载、验证和评估上述配置文件：</p><p>请注意，我们还可以安装我们自己的定制值/函数，以供用户在其配置文件中引用。例如：</p><p>loadConfig：：FilePath-&gt；IO(字符串配置)loadConfig=valFile&#39；envs(仅模式)，其中envs=installBinding&#34；System&#34；Text(inj System.Info.os)。installBinding&#34；TakeFileName&#34；(TFun Text Text)(Inj TakeFileName)。installBinding&#34；TakeDirectory&#34；(TFun Text Text)(Inj TakeDirectory)。installBinding&#34；doPathExist&#34；(TFun文本文本TBool)(Inj Dos PathExist)--NB：这执行IO读取$initEnvironment。</p><p>最后，我们不需要将自己限制在指定记录值的配置文件中。我们可以将Expresso函数值投影到Haskell函数(IO中)，从而允许更高阶的配置文件！投影本身由HasValue类处理，就像任何其他值一样：</p><p>Haskell&gt；right(f：：整数-&gt；IO整数)&lt；-valString(仅$TFun tint tint)&#34；x-&gt；x+1&#34；Haskell&gt；f 1 2。</p><p>可扩展记录和变体的多态类型系统&#34；B.R.Gaster和M.P.Jones，1996。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/willtim/Expresso">https://github.com/willtim/Expresso</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/多态/">#多态</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>