<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Windows控制台上读取UTF-8密码</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>如何在Windows控制台上读取UTF-8密码</h1><div class="row"><div class="col-lg-8 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time">2020-05-04 21:26:04</div><p>假设您正在编写一个命令行程序，提示用户输入密码或口令短语，而Windows是其中一个受支持的平台(即使是非常旧的版本)。该程序使用UTF-8作为其字符串表示，这是理所当然的，因此理想情况下，它会从用户那里接收编码为UTF-8的密码。在大多数平台上，这在很大程度上是自动的。然而，在Windows上寻找这个问题的正确答案是一个迷宫，所有的标志都通向死胡同。我最近穿过这个迷宫，找到了出口。</p><p>我知道这是可能的，因为我的passphrase2pgp工具使用了golang.org/x/crypto/ssh/Terminal包，这使它近乎完美。尽管他们6个月前还在修复细微的错误。</p><p>第一步是忽略你在网上找到的所有东西，因为它要么是错的，要么是在解决一个略有不同的问题。稍后我将讨论死胡同，并首先关注解决方案。最终，我希望在Windows上实现此功能：</p><p>//显示提示，然后读取以零结尾的UTF-8密码。//带终止符返回密码长度，错误时返回零。int read_password(char*buf，int len，const char*Prompt)；</p><p>我选择int作为长度，而不是size_t，因为它是密码，甚至不应该接近int_max。</p><p>这种方法的一个很大的优点是它不依赖于标准输入和标准输出。其中一个或两个都可以重定向到其他地方，并且此功能仍然与用户的终端交互。Windows版本也将拥有同样的优势。</p><p>尽管有一些诱人的快捷方式不起作用，但Windows上的步骤基本上是相同的，只是名称不同。有两个实体和额外的步骤。我将忽略下面代码片段中的错误，但是完整的示例有完整的错误处理。</p><p>该程序使用CreateFileA()打开两个文件，而不是/dev/tty：conin$和CONOUT$。注：“A”代表ANSI，而“W”代表宽(Unicode)。这指的是文件名的编码，而不是文件内容的编码方式。由于需要写入权限才能更改控制台的模式，因此打开了conin$以供读取和写入。</p><p>Handle hi=CreateFileA(&#34；Conin$&#34；，GENERIC_READ|GENERIC_WRITE，0，0，OPEN_EXISTING，0，0)；HANDLE ho=CreateFileA(&#34；CONOUT$&#34；，GENERIC_WRITE，0，0，OPEN_EXISTING，0，0)；</p><p>要编写提示符，请在输出句柄上调用WriteConsoleA()。就其本身而言，它假定提示符是纯ASCII(即&#34；密码：&#34；)，而不是UTF-8(即&#34；对比度：&#34；)：</p><p>如果提示符可能包含UTF-8数据(可能是因为它显示的是username或不是英语)，则您有两个选择：</p><p>将SetConsoleOutputCP()与CP_utf8(65001)一起使用。这是全局(到控制台)设置，完成后应恢复。</p><p>接下来，使用GetConsoleMode()和SetConsoleMode()禁用回显。控制台通常已经设置了ENABLE_PROCESSED_INPUT，它告诉控制台处理CTRL-C等，但我显式设置了它以防万一。我还设置了ENABLINE_LINE_INPUT，这样用户就可以使用退格键，这样就可以一次发送整行内容。</p><p>有报告称ENABLE_LINE_INPUT将读取限制为254字节，但我无法重现它。我的完整示例可以毫不费力地阅读大量密码。</p><p>这是你必须付钱给风笛手的地方。截至本文日期，Windows API还没有提供从控制台读取UTF-8输入的方法。现在就放弃这个希望吧。如果您在任何配置下使用“ANSI”函数来读取输入，它们将与通常的Windows一样默默地破坏您的输入。</p><p>因此，您必须使用UTF-16API ReadConsoleW()，然后自己编码。幸运的是，Win32提供了一个UTF-8编码器WideCharToMultiByte()，它甚至可以为所有喜欢在密码中放入一堆便便(U+1F4A9)的人处理代理项对：</p><p>WCHAR*wbuf=malloc((len-1+2)*sizeof(*wbuf))；DWORD nREAD；ReadConsoleW(hi，wbuf，len-1+2，&amp；nREAD，0)；wbuf[nREAD-2]=0；//截断&#34；\r\n&#34；int r=WideCharToMultiByte(CP_UTF8，0，wbuf。</p><p>分配中的+2用于稍后将被截断的CRLF线路末尾。错误处理版本检查输入是否确实以CRLF结尾。否则它会被截断(太长)。</p><p>最后，由于没有回显用户键入的换行符，因此打印一个换行符，恢复旧的控制台模式，关闭控制台句柄，并返回最终编码的长度：</p><p>错误检查版本不检查来自任何这些函数的错误，因为它们要么不会失败，要么在出现错误时没有任何合理的处理方法。</p><p>如果您环顾一下Win32API，您可能会注意到SetConsoleCP()。合理的人可能认为将“代码页”设置为UTF-8(CP_UTF8)可能会将控制台配置为以UTF-8编码输入。好消息是Windows将不再像以前那样破坏你的输入。坏消息是，它将受到不同的破坏。</p><p>您可能认为可以在连接到控制台的文件*上使用CRT函数_setmode()和_O_U8TEXT。这没有什么用处。(_setmode()的唯一用法是WITH_O_BINARY，用于在标准输入和输出上禁用braindead字符转换。)。对于CRT，您能做的最好的事情就是使用非标准函数读取相同类型的宽字符，然后转换为UTF-8。</p><p>CredUICmdLinePromptForCredentials()承诺既有足够的函数名，又有这个问题的预先打包的解决方案，它只在第一个函数上提供。这项功能似乎在一段时间前就失效了，微软没有人注意到这一点--可能是因为从来没有人使用过这项功能。我找不到可用的示例，也找不到在任何实际应用程序中使用的示例。当我试图使用它的时候，我得到了一个无稽之谈的错误代码，它从来没有起作用。这个函数有一个可以工作的GUI版本，对于某些情况，它是一个可行的替代方案，尽管我的情况不是这样。</p><p>在我最绝望的时候，我希望启用虚拟终端处理会是一个神奇的开关。在Windows10上，它神奇地启用了一些ANSI转义序列。文档没有以任何方式暗示它会起作用，我通过实验证实它不会起作用。可怜。</p><p>我花了很多时间寻找这些死胡同，直到最终使用上面的ReadConsoleW()解决了问题。我希望它能更自动化，但我很高兴我至少想出了一些解决方案。</p><p>对这篇文章有什么评论吗？通过发送电子邮件至~Skeeto/public-inbox@lists.sr.ht[邮件列表礼仪]开始我的公共收件箱中的讨论，或查看现有讨论。</p><div class="text-break sotry_link"><a target="_blank" href="https://nullprogram.com/blog/2020/05/04/">https://nullprogram.com/blog/2020/05/04/</a></div><div class="story_tags"><button type="button" class="btn btn-light my_tag"><a href="/tag/密码/">#密码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/utf-8/">#utf-8</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/utf/">#utf</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/input/">#input</a></button></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/百度/">#百度</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/搜索/">#搜索</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>