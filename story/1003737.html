<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>围棋中的工具</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">围棋中的工具</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-26 08:31:50</div><div class="page_narrow text-break page_content"><p>在这篇文章中，我将分享我对围棋程序应该如何以一种干净而灵活的方式进行测试的看法。</p><p>日志记录、度量集合以及与某些代码的主要功能无关的任何内容都不得出现在该代码中。取而代之的是可以由用户检测的代码的定义跟踪点。</p><p>让我们假设我们有一个名为lib的包和一些lib.clientstructure，它们在每次执行somquest时都会ping其底层连接。</p><p>包库类型客户端结构{conn net.。conn}函数(c*客户端)请求(CTX上下文。上下文)错误{if err：=c..。ping(Ctx)；err！=nil{return err}//这里有一些逻辑。}func(c*client)ping(CTX上下文。上下文)错误{返回掺杂(CTX，c.。CONN)}。</p><p>如果我们需要在ping发生之前和之后写入一些日志，该怎么办？一种方法是将一些记录器(或记录器接口)注入客户端：</p><p>包库类型客户端结构{Logger Logger Conn Net.。conn}函数(c*客户端)ping(CTX上下文。上下文)(错误){c..。伐木者。信息(&#34；ping开始&#34；)错误=掺杂(CTX，c.。conn)c.。伐木者。信息(&#34；ping已完成(错误为%v)&#34；，错误)返回}。</p><p>包库类型客户端结构{Logger Logger Metrics Registry Conn Net.。conn}函数(c*客户端)ping(CTX上下文。上下文)(错误){开始：=时间。现在()c.。伐木者。信息(&#34；ping开始&#34；)错误=掺杂(CTX，c.。conn)c.。伐木者。信息(&#34；ping已完成(错误为%v)&#34；，err)度量：=c..。指标。获取(&#34；PING_LATHERY&#34；)指标。发送(时间。自(开始))返回错误}。</p><p>如果我们继续向客户端添加检测方法，我们将意识到它的大部分代码都与检测相关，而不是与客户端的主要功能相关(这只是一行带有掺杂()调用的代码)。</p><p>不连贯的(与我们客户的主要目的无关)代码行数只是该方法的第一个问题。</p><p>如果在程序的操作过程中，您意识到度量名称(例如，指标名称)是错误的，并且您应该将其重命名，该怎么办呢？或者您必须使用一些不同的库来记录日志？</p><p>使用上面的方法，您将需要转到客户端的实现(以及其他类似的组件)并对其进行更改。</p><p>这意味着每当与组件的主要功能无关的内容发生更改时，您都要更改代码。换句话说，这样的设计确实违反了SRP原则。</p><p>如果您在多个程序之间共享代码，该怎么办？如果您甚至根本无法控制代码的使用者(老实说，我建议将每个包视为被未知数量的程序重用的包，即使实际上只有一个包是您的)。</p><p>在我看来，正确的方法是定义跟踪点(又名钩子)，然后代码用户可以在运行时使用某个函数(又名探测)初始化这些跟踪点。</p><p>当然，这仍然会增加一些额外的代码行，但也会给用户带来灵活性，让他们可以使用任何适当的方法来测量我们组件的运行时。</p><p>让我们提供几乎相同的机制，但有一个变化。我们不提供OnPingStart()和OnPingDone()挂钩，而是引入单个OnPing()挂钩，该挂钩将在ping之前被调用，并将返回一个回调，后者将在ping之后立即被调用。这样，我们可以将一些变量存储在闭包中，以便在ping完成时访问它们(例如，计算ping延迟)。</p><p>包库类型客户端结构{OnPing func()func(Error)conn net.。conn}函数(c*客户端)ping(CTX上下文。上下文)(错误){完成：=c..。OnPing()Err=掺杂(CTX，c.。conn)完成(错误)返回}。</p><p>看起来很整洁，但除非我们意识到OnPing挂钩和回调它的返回可能都为零：</p><p>函数(c*客户端)ping(CTX上下文。上下文)(错误){如果fn：=c，则变量完成函数(错误)。OnPing；Fn！=nil{Done=Fn()}Err=掺杂(CTX，c.。conn)如果完成！=nil{Done(Err)}return}。</p><p>现在它是正确的，仍然擅长灵活性和SRP原则，但不太擅长代码简单性。</p><p>在简化代码之前，让我们先讨论一下当前钩子实现还存在的另一个问题。</p><p>用户将如何设置多个探测器？因此，前面提到的httptrace包具有ClientTrace.compose()方法，该方法将两个跟踪结构合并到第三个跟踪结构中。因此，result tingtrace中的每个探测函数都将调用先前跟踪中的相应探测(如果设置了它们的话)。</p><p>因此，让我们首先尝试手动执行相同的操作(并且不使用反射)。为此，我们将OnPing挂钩从客户端移至单独的结构ClientTrace：</p><p>包库类型客户端结构{Trace ClientTrace conn net.。conn}type ClientTrace struct{OnPing func()func(Error)}</p><p>func(A ClientTrace)Compose(B ClientTrace)(C ClientTrace){Switch{case a.。OnPing==nil：c.。OnPing=b.。安平案件b。OnPing==nil：c.。Onping=a.。OnPing默认值：c.。onPing=func()func(错误){doona：=a.。On Ping()Done B：=b.。onPing()开关{case dona==nil：return donB case donA B==nil：return dona默认值：return func(Err Error){dona(Err)donB(Err)}return c}。</p><p>单钩的代码很多，对吧？现在让我们继续前进，稍后再回来讨论这个问题。</p><p>包主导入(&#34；log&#34；&#34；ome/path/to/lib&#34；)func main(){var trace lib.。ClientTrace//日志挂钩。TRACE=跟踪。作曲(唱词)。ClientTrace{OnPing：func()函数(错误){日志。Println(&#34；ping start&#34；)返回函数(错误){日志。Println(&#34；ping Done&#34；，Err)}}，})//一些指标挂钩。TRACE=跟踪。作曲(唱词)。ClientTrace{OnPing：func()func(错误){start：=time.。NOW()返回函数(错误){METRY：=STATS。获取(&#34；PING_LATHERY&#34；)指标。发送(时间。由于(Start))}}，})c：=lib。客户端{跟踪：跟踪，}}。</p><p>我们还可以为用户提供的一件事是基于上下文的跟踪。也就是说，它与httptrace包中的完全相同-能够将挂钩与传递给Client.Request()的context.Context相关联。</p><p>包库类型clientTraceContextKey struct{}func ClientTrace(CTX上下文。上下文)ClientTrace{t，_：=ctx.。value(clientTraceContextKey{})return t}func WithClientTrace(CTX上下文。上下文，t ClientTrace)上下文。context{prev：=ContextClientTrace(Ctx)返回上下文。WithValue(CTX，clientTraceContextKey{}，Prev.。作曲(T)，)}。</p><p>哈。看起来现在差不多完成了，我们已经准备好为我们组件的用户带来所有最好的跟踪工具。</p><p>但是，为我们想要检测的每个结构编写所有代码不是真的很乏味吗？当然，您可以为此编写一些vim的宏(实际上我以前也是这样做的)，但是让我们看看替代方法。</p><p>好消息是合并钩子和检查nil，以及特定于上下文的函数都是模式化的，所以我们可以在没有宏或反射的情况下为它们生成GO代码。</p><p>gtrace是一个命令行工具，它为上面讨论的tracingmethod生成GO代码。它建议您使用带有钩子字段的结构(用//gtrace：gen标记)，并围绕它们生成帮助器函数，这样您就可以合并这样的结构并调用钩子，而无需任何检查。它还可以生成上下文感知帮助器来调用与上下文相关联的挂钩。</p><p>Package lib//go：生成gtrace//gtrace：gen//gtrace：设置上下文类型ClientTrace struct{OnPing func()func(Error)}type client struct{Trace ClientTrace conn net。conn}函数(c*客户端)ping(CTX上下文。上下文)(错误){完成：=c..。痕迹。onPing(CTX)ERR=掺杂(CTX，c.。conn)完成(错误)返回}。</p><p>运行Go Generate之后，我们将能够使用在ClientTrace中定义的生成的非导出版本的跟踪挂钩。</p><p>就这样!。gtrace负责样板代码，并允许您将注意力集中在您希望能够由用户检测的跟踪点上。</p><p>克里斯韦隆的极简主义C库。我很久以前读过这篇文章，关于图书馆如何组织的清晰想法给了我灵感。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gbws.io/articles/instrumentation-in-go/">https://gbws.io/articles/instrumentation-in-go/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/围棋/">#围棋</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>