<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Auth0控制对新AWS API网关HTTP API的访问</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Auth0控制对新AWS API网关HTTP API的访问</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-29 07:49:49</div><div class="page_narrow text-break page_content"><p>几周前，AWS API Gateway HTTP API正式上市，提供了一种更简单、更快、更便宜的API构建方式。简化的功能之一是整个授权案例，这也是我们将在这篇博客文章中介绍的内容。</p><p>对于传统的RESTAPI，您通常会使用Lambda函数编写自己的Custom Authorizer来支持JWT授权(主要是在OpenID Connect和OAuth 2.0的上下文中)。HTTP API不再需要这样做，因为它提供了开箱即用的JWT授权器。</p><p>这意味着您可以通过提供3个简单设置来配置您自己的JWT授权器，而不必部署和维护您的自定义授权器：</p><p>让我们看看如何将Auth0配置为JWT授权程序。我们将构建一个简单的API，使用公共端点和私有端点返回颜色，要求用户首先进行身份验证。</p><p>在您的帐户中，您将希望将HTTP API表示为Auth0中的API，您需要为其指定名称和标识符。标识符最终将成为您的JWT Authorizer的受众。</p><p>我还将在Applications下创建一个单页应用程序，因为我将编写一个小的Reaction应用程序来与HTTP API交互。另外，这里的配置相对简单。</p><p>我们将在Auth0端做的最后一件事是编写一条规则，该规则将向access_Token添加一些自定义声明：</p><p>函数(用户、上下文、回调){上下文。accessToken[&#39；http://sandrino/roles&#39；]=[&#39；admin&39；，&#39；Member&#39；]；上下文。accessToken[&#39；http://sandrino/email&#39；]=用户。电子邮件；上下文。accessToken[&#39；http://sandrino/email_verified&#39；]=用户。电子邮件已验证(_V)。toString()；返回回调(null，user，context)；}</p><p>而这实际上就是它的全部。让我们继续讨论HTTP API。</p><p>有很多资源(auth0.com博客上的示例)向您展示了如何在AWS控制台中配置JWT授权程序，因此在这篇文章中，我们将使用无服务器框架。</p><p>我的API启用了CORS，因为我们希望浏览器能够与其交互。</p><p>Auth0被配置为授权者，只需提供我们在Auth0仪表板中创建的API的颁发者URL和受众。</p><p>我们有两个端点：/Colors，它是公共的(没有配置授权者)，以及/my/profile，它将授权请求。</p><p>服务：HTTP-API-JWT-示例提供程序：名称：AWS运行时：nodejs12.x httpApi：CORS：alloweHeaders：-Content-Type-Authorization AllowedMethods：-Get-Options AllowedOrigins：-http：//localhost：3000 payload：&#39；2.0&#39；授权者：accessTokenAuth0：IdentitySource：$request.header.Authorization IsorerUrl：https：//sandrino.auth0.com/Audience：-urn：Colors-API函数：#列出所有颜色(公共端点)getColors：Handler.Colors事件：-httpApi：Method：Get Path：/Colors#列出我的配置文件(需要授权)myProfile：Handler.myProfile Events：-httpApi：Method：Get Path：</p><p>如果我们应用此配置，您将在您的AWS控制台中看到一个新的JWT授权程序：</p><p>在Auth0中使用自定义域时，应将该域配置为IssuerUrl。因此，例如，您应该使用https://auth.sandrino.dev/而不是https://sandrino.auth0.com/.</p><p>当为路由配置了JWT Authorizer时，您就不必担心解析和验证令牌了。如果提供了有效令牌，则声明将在事件中可用-否则请求将失败。下面是一个函数示例，该函数访问JWT授权程序提供的声明，并提取我们可能已添加的任何自定义声明(使用Auth0规则)：</p><p>模块。出口。myProfile=异步(事件)=&gt；{常量索赔=事件。requestContext。授权者。JWT。索赔；返回{id：Claims。子角色：索赔[&#39；http://sandrino/roles&#39；]，索赔}；}；</p><p>我们还将创建一个简单的Next.js应用程序，它使用auth0-spa-js从浏览器登录。</p><p>导入{}from&#39；@auth0/auth0-spa-js&#39；；export default new({DOMAIN：&#39；https://sandrino.auth0.com&#39；，//如果您已配置Client_id：&#39；z9p3mE4Oc1PN4XKooapkPpn22nRONdJC&#39；，Audience：&#39；urn：Colors-api&#39；，//这应该是的受众，则应为您的Auth0域或自定义域。OpenID配置文件电子邮件&#39；})；</p><p>在用户登录之后，我们将使用一个Reaction钩子从我们的API中获取数据：</p><p>EXPORT DEFAULT()=&gt；{const{data，error，isending，get}=useApi(Process.。环境。API_Gateway_BASE_URL)；const getColors=()=&gt；get(&#39；/Colors&#39；，{auth：false})；const getMyProfile=()=&gt；get(&#39；/my/profile&#39；)；return(&lt；&gt；&lt；mb={5}isInline Spacing={4}&gt；&lt；size=&#34；md&#34。onclick={getColors}&gt；&lt；/&gt；&lt；size=&#34；md&#34；onclick={getMyProfile}&gt；&lt；/&gt；&lt；/&gt；&lt；code={(待定&amp；&amp；&39；//正在加载.&#39；)||(错误&amp；&amp；。stringify(error，null，2)||(数据&amp；&amp；。stringify(data，null，2)||&#39；//按上面的一个按钮调用API Gateway&#39；}language=&#34；json&#34；/&gt；&lt；/&gt；)；}；</p><p>useApi是一个自定义的反应挂钩，它从auth0-spa-js检索access_Token并将其附加到HTTP请求的Authorization头。实现可以在示例项目中找到。</p><p>但是，当我们确实通过Auth0登录并且Access_Token在HTTP请求中提供时，JWT Authorizer将允许请求通过我们的处理程序：</p><p>您会注意到，这里的颁发者设置为https://auth.sandrino.dev/，因为我正在使用我的Auth0自定义域执行所有测试。</p><p>在每个路由上，您还可以选择配置授权作用域，从而允许您定义令牌中应该存在哪个作用域来访问API路由。在下面的示例中，您可以看到我现在需要新端点的Read：Colors作用域：</p><p>如果您正在使用无服务器框架，您只需将所需的范围添加到您的路由即可：</p><p>myColors：Handler.myColors事件：-httpApi：Method：Get Path：/my/Colors Authizer：Name：accessTokenAuth0 Scope：-Read：Colors。</p><p>您的lambda函数不需要更改代码，一切都由JWT Authorizer处理。您需要做的唯一更改是在客户端请求此作用域：</p><p>导入{}from&#39；@auth0/auth0-spa-js&#39；；export default new({DOMAIN：&#39；https://sandrino.auth0.com&#39；，//如果您已配置Client_id：&#39；z9p3mE4Oc1PN4XKooapkPpn22nRONdJC&#39；，Audience：&#39；urn：Colors-api&#39；，//这应该是的受众，则应为您的Auth0域或自定义域。OpenID配置文件电子邮件内容：Colors&#39；//我们在此请求额外的作用域})；</p><p>真正有趣的是与Auth0&#39；的基于角色的访问控制功能的链接，在那里我们可以使用角色和权限控制对特定范围的访问。让我们来看一个例子。在API上，我们将配置一个新的Read：Colors权限：</p><p>作为这项工作的一部分，我们还需要为API启用授权策略(启用RBAC切换)。这将要求用户具有正确的权限集：</p><p>启用此设置时，用户需要具有“读取：颜色”权限，否则将不允许该作用域。因此，即使客户端请求OpenID配置文件电子邮件Read：Colors，令牌最终也将如下所示：</p><p>{&#34；http://sandrino/email&#34；：&#34；sandrino@auth0.com&34；，&#34；http://sandrino/email_verified&#34；：&#34；true&#34；，&#34；iss&#34；：&#34；https://auth.sandrino.dev/&#34；，&#34；sub&#34；：&#34；auth0|593b80d5f8a341400599ce4f&#34；，&#34；aud&#34；：[&#34；urn：Colors-api&#34；，&#34；https://sandrino.auth0.com/userinfo&#34；]，&#34；iat&#34；：1590666735，&#34；exp&#34；：1590753135，&#34；azp&#34；：&#34；z9p3mE4Oc1PN4XKooapkPpn22nRONdJC&#34；，&#34；Scope&#34；：&#34；openid。</p><p>请注意，Read：Colors作用域是如何不存在的，即使它是由客户端请求的。</p><p>因此，对我们创建的新端点的调用将失败，因为我们的令牌缺少正确的作用域：</p><p>让我们继续在Auth0中创建一个角色，我们将向该角色添加Read：Colors权限。通过将权限添加到此角色，分配了此角色的任何用户都将能够接收Read：Colors作用域。</p><p>现在，当用户登录时，您会注意到一个重要的差异，即Read：Colors范围可用。</p><p>{&#34；http://sandrino/email&#34；：&#34；sandrino@auth0.com&34；，&#34；http://sandrino/email_verified&#34；：&#34；true&#34；，&#34；iss&#34；：&#34；https://auth.sandrino.dev/&#34；，&#34；sub&#34；：&#34；auth0|593b80d5f8a341400599ce4f&#34；，&#34；aud&#34；：[&#34；urn：Colors-api&#34；，&#34；https://sandrino.auth0.com/userinfo&#34；]，&#34；iat&#34；：1590678148，&#34；exp&#34；：1590764548，&#34；azp&#34；：&#34；z9p3mE4Oc1PN4XKooapkPpn22nRONdJC&#34；，&#34；Scope&#34；：&#34；openid。</p><p>当我们尝试访问新端点时.。它起作用了!。在所需的范围内，我们可以呼叫新路由：</p><p>您的用户需要从Auth0中收回一个新的访问令牌，这样的更改才会在您的应用程序中生效。这可以通过再次登录、通过静默身份验证(使用IFRAME)或使用刷新令牌来实现。</p><p>正如您已经看到的，使用JWT Authorizers可以非常容易地涵盖API Gateway的授权方面。虽然本文关注的是最终用户身份验证，但同样的ACCESS_TOKEN和Scope概念也适用于代表您的API与您的API对话的应用程序。</p><p>在GitHub上可以找到无服务器框架项目和Next.js应用程序的完整示例。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sandrino.dev/blog/aws-api-gateway-jwt-auth0">https://sandrino.dev/blog/aws-api-gateway-jwt-auth0</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1003821.html"><img src="http://img.diglog.com/img/2020/5/thumb_197dfbc57ca8905594612a7569f4fa7c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003821.html">印度政府开源Aarogya Setu-其COVID19跟踪应用</a></div><span class="my_story_list_date">2020-5-27 3:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002380.html"><img src="http://img.diglog.com/img/2020/5/thumb_00bbc7fd7c30910f969897267423d001.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002380.html">Python Flask REST API和Sqlite DB AS数据存储，不超过100行</a></div><span class="my_story_list_date">2020-5-16 18:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002239.html"><img src="http://img.diglog.com/img/2020/5/thumb_cd2446b0314b331cdd33a4d5711d7ef2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002239.html">如何将JSON数据从API导入到Google工作表</a></div><span class="my_story_list_date">2020-5-15 23:38</span></div><div class="col-sm"><div><a target="_blank" href="/story/1001725.html"><img src="http://img.diglog.com/img/2020/5/thumb_0e919b31e7aed180c085cd60434eb626.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1001725.html">MetaMate-您的API无所不能</a></div><span class="my_story_list_date">2020-5-12 5:58</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>