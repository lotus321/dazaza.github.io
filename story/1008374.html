<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>固定你的时间步长</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">固定你的时间步长</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-26 16:48:46</div><div class="story_img_container"><img src="http://img.diglog.com/img/2020/6/01b18dc0f66b2879b49698fca2e98997.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></div><div class="page_narrow text-break page_content"><p>在前一篇文章中，我们讨论了如何使用数值积分器对运动方程进行积分。集成听起来很复杂，但它只是一种将物理模拟向前推进一小段时间的方法，称为“增量时间”(或简称DT)。</p><p>但是如何选择这个增量时间值呢？这看起来可能是一个微不足道的话题，但实际上有很多不同的方法，每种方法都有自己的长处和短处-所以请继续读下去！</p><p>前进的最简单方法是使用固定的增量时间，如1/60秒：</p><p>DOUBLE t=0.0；DOUBLE DT=1.0/60.0；WHILE(！QUIT){INTEGRATE(STATE，t，DT)；RENDER(STATE)；t+=DT；}。</p><p>在许多方面，该代码都是理想的。如果您足够幸运地让增量时间与显示刷新率匹配，并且可以确保更新循环占用的实时时间少于一帧，那么您已经有了更新物理模拟的完美解决方案，您可以停止阅读本文。</p><p>但在现实世界中，您可能无法提前知道显示刷新率。Vsync可能被关闭，或者您可能运行在一台速度较慢的计算机上，该计算机无法以60fps的速度更新和渲染帧。</p><p>解决这个问题似乎很简单。只需测量前一帧花费的时间，然后将该值作为下一帧的增量时间反馈回来。当然，这是有意义的，因为如果计算机以60 Hz的速度更新太慢，并且必须降至30fps，您将自动传入1⁄30作为增量时间。对于75 Hz而不是60 Hz的显示刷新率，甚至在速度较快的计算机上关闭Vsync的情况下，情况也是如此：</p><p>Double t=0.0；Double currentTime=hires_time_in_sec()；While(！Quit){Double newTime=hires_time_in_sec()；Double Frame Time=newTime-currentTime；currentTime=newTime；Integrate(state，t，frame Time)；t+=frame Time；Render(State)；}</p><p>但是这种方法有一个巨大的问题，我现在要解释一下。问题是物理模拟的行为取决于您传入的增量时间。效果可能是微妙的，因为你的游戏根据帧速率有稍微不同的“感觉”，或者它可能是极端的，就像你的弹簧模拟爆炸到无限大，快速移动的物体穿过墙壁，玩家跌倒在地板上！</p><p>不过，有一件事是可以肯定的，那就是期望您的模拟正确处理传入的任何增量时间是完全不切实际的。要了解原因，请考虑如果将十分之一秒作为增量时间传递会发生什么情况？一秒怎么样？10秒？100秒？最终你会找到一个突破点。</p><p>更现实的说法是，只有当增量时间小于或等于某个最大值时，您的模拟才表现良好。在实践中，这通常比尝试在大范围的增量时间值下使模拟防弹容易得多。</p><p>有了这些知识，这里有一个简单的技巧，可以确保您在不同的计算机上仍以正确的速度运行时，永远不会经过大于最大值的增量时间：</p><p>Double t=0.0；Double dt=1/60.0；Double currentTime=hires_time_in_sec()；While(！Quit){Double newTime=hires_time_in_sec()；Double Frame Time=newTime-currentTime；currentTime=newTime；While(frame Time&gt；0.0){Float deltaTime=min(frame Time，dt)；Integrate(state，t，deltaTime)；frame Time-。</p><p>这种方法的好处是我们现在有了增量时间的上限。它永远不会大于这个值，因为如果大于，我们就细分时间步长。缺点是我们现在对每个显示的更新采取多个步骤，包括一个额外的步骤来消耗任何不能被DT整除的帧时间的剩余部分。如果你被渲染限制，这是没有问题的，但是如果你的模拟是你的帧中最昂贵的部分，你可能会陷入所谓的“螺旋式死亡”。</p><p>死亡的螺旋是什么？这是当你的物理模拟跟不上要求它采取的步骤时会发生的事情。例如，如果你的模拟被告知：“好的，请模拟X秒的物理”，如果Y&gt；X需要Y秒的实时时间才能做到这一点，那么不需要爱因斯坦就会意识到，随着时间的推移，你的模拟落后了。之所以称为死亡螺旋，是因为落后会导致您的更新模拟更多的步骤以迎头赶上，这会导致您进一步落后，这会导致您模拟更多的步骤…。</p><p>那么我们如何避免这种情况呢？为了确保稳定的更新，我建议留出一些余地。您确实需要确保更新相当于X秒的物理模拟所需的实时时间明显少于X秒。如果你能做到这一点，那么你的物理引擎就可以通过模拟更多的帧来“赶上”任何暂时的峰值。或者，您可以钳制每帧的最大步数，模拟将在重载下显示为减慢。可以说，这比螺旋式死亡要好，特别是如果沉重的负荷只是一个暂时的峰值。</p><p>现在让我们再往前走一步。如果您希望在给定相同输入的情况下从一次运行到下一次运行具有精确的重现性，该怎么办？这在尝试使用确定性锁步将物理模拟联网时非常有用，但通常也是一件很好的事情，因为您的模拟在每次运行到下一次运行时的行为完全相同，没有任何潜在的不同行为，具体取决于渲染帧率。</p><p>但您会问，为什么需要完全固定的Delta时间才能做到这一点？剩余步长较小的半固定增量时间肯定“足够好”吗？是的，你是对的。它在大多数情况下是足够好的，但由于浮点运算的精度有限，它并不完全相同。</p><p>那么我们想要的是两全其美：模拟的固定增量时间值加上以不同帧速率渲染的能力。这两件事看起来完全不一致，它们确实是不一致的-除非我们能找到一种方法来分离模拟和渲染帧速率。</p><p>下面是如何做到这一点的。以固定的DT时间步长提前物理模拟，同时确保它与来自渲染器的计时器值保持一致，以便模拟以正确的速率前进。例如，如果显示帧率为50fps，模拟运行速度为100fps，则每次显示更新都需要执行两个物理步骤。很简单。</p><p>如果显示帧速率是200fps，该怎么办？在这种情况下，我们需要在每次显示器更新时采取半个物理步骤，但我们不能这样做，我们必须以恒定的DT前进，所以我们每两次显示器更新就采取一个物理步骤。</p><p>更棘手的是，如果显示帧速率是60fps，但我们希望我们的模拟以100fps运行，该怎么办？没有容易的倍数。如果禁用了Vsync，并且显示帧速率随帧而波动，该怎么办？</p><p>如果你的头刚刚爆炸了，别担心，解决这个问题所需要的就是改变你的观点。不要认为在渲染之前必须模拟一定数量的帧时间，而是将视点颠倒过来，这样想：渲染器生成时间，模拟以离散DT大小的步长消耗时间。</p><p>双t=0.0；常量双Dt=0.01；双currentTime=hires_time_in_sec()；双累加器=0.0；While(！Quit){Double newTime=hires_time_in_sec()；双帧时间=newTime-currentTime；currentTime=newTime；累加器+=frame Time；While(累加器&&gt;；=dt){Integrate(state，t，dt)；累加器-=dt；</p><p>请注意，与半固定的时间步长不同，我们只与步长大小为dT的步长进行积分，因此在通常情况下，我们在每帧的末尾都会留下一些未模拟的时间。剩余的时间通过累加器变量传递到下一帧，并且不会被丢弃。</p><p>但是剩下的这段时间怎么办呢？好像不太对劲，不是吗？</p><p>要了解正在发生的情况，请考虑这样一种情况：显示帧速率为60fps，物理运行速率为50fps。没有合适的倍数，所以累加器使模拟在每帧主要采用一个物理步长和偶尔采用两个物理步长之间交替，当剩余物“累积”在DT以上时。</p><p>现在考虑大多数渲染帧将在累加器中留下一些不能模拟的帧时间，因为它小于DT。这意味着我们在与渲染时间略有不同的时间显示物理模拟的状态，导致屏幕上的物理模拟出现细微的但视觉上令人不快的卡顿。</p><p>此问题的一种解决方案是基于累加器中剩余的时间在先前和当前物理状态之间进行插值：</p><p>双t=0.0；双Dt=0.01；双currentTime=hires_time_in_sec()；双累加器=0.0；状态上一；当前状态；While(！Quit){Double newTime=Time()；Double Frame Time=newTime-currentTime；if(frame Time&gt；0.25)frame Time=0.25；currentTime=newTime；累加器+=Frame Time；While(累加器&&gt;；=dt){previousState。state state=currentstate*alpha+previousState*(1.0-alpha)；Render(State)；}。</p><p>这看起来很复杂，但这里有一个简单的思考方法。累加器中的任何剩余部分实际上都是在采取另一个完整的物理步骤之前还需要多少时间的度量。例如，dt/2的余数意味着我们目前处于当前物理步骤和下一个物理步骤之间。DT*0.1的余数表示更新是当前状态和下一状态之间的十分之一。</p><p>只需除以dt，我们就可以使用这个余数值来获得前一个物理状态和当前物理状态之间的混合因子。这给出了范围[0，1]中的alpha值，它用于在两个物理状态之间执行线性插值，以获得要渲染的当前状态。对于单个值和矢量状态值，此插值很容易完成。如果将方向存储为四元数并使用球面线性插值(SLERP)在先前和当前方向之间混合，则甚至可以将其与完整的3D刚体动力学一起使用。</p><p>格伦·菲德勒是Network Next的创始人兼首席执行官。Network Next正在通过创建一个高端网络传输市场来修复游戏的互联网。</p></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gafferongames.com/post/fix_your_timestep/">https://gafferongames.com/post/fix_your_timestep/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fix/">#fix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模拟/">#模拟</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1008131.html"><img src="http://img.diglog.com/img/2020/6/thumb_39989abec71007cb7264847021d2cd25.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008131.html">新冠肺炎规则的缓慢放松有助于推迟复发</a></div><span class="my_story_list_date">2020-6-25 18:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1008126.html"><img src="http://img.diglog.com/img/2020/6/thumb_711757af7f3e996def35ffd7d738ef85.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1008126.html">每辆车通往GPS的漫长而曲折的技术之路</a></div><span class="my_story_list_date">2020-6-25 18:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1007376.html"><img src="http://img.diglog.com/img/2020/6/thumb_ab0904869c9a836a9464b50a267b42d2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1007376.html">他们独自生活在鬼城</a></div><span class="my_story_list_date">2020-6-20 11:21</span></div><div class="col-sm"><div><a target="_blank" href="/story/1006754.html"><img src="http://img.diglog.com/img/2020/6/thumb_0fc7b94051f5fc8e4d5b0a9139415d53.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1006754.html">基于LSTM的时间序列实体嵌入</a></div><span class="my_story_list_date">2020-6-16 9:3</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/app/">#app</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/病毒/">#病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/冠状病毒/">#冠状病毒</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>